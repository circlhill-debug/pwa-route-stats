<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<!-- Progressive Web App metadata -->
<meta name="theme-color" content="#2b7fff" />
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-180.png" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="RouteStats" />
<title>Route Stats — Live Dashboard</title>
<style>
  :root{
    --bg:#0f1115; --card:#141821; --border:#22262e; --text:#e8e8ea; --muted:#9aa0aa; --brand:#2b7fff;
    --good:#7CE38B; --warn:#FFD27A; --bad:#FF8FA1;
    --rs-neg:#17803d;   /* under time = green */
    --rs-pos:#c0392b;   /* over time  = red   */
    --rs-mute:#6b7280;  /* neutral/gray      */
    --rs-cell:rgba(0,0,0,0.06);
    --rs-cell-dark:rgba(255,255,255,0.10);
    --rs-grid:rgba(154,160,170,0.45);
    --rs-grid-dark:rgba(224,228,236,0.45);
    --safe-top: env(safe-area-inset-top);
    --safe-bottom: env(safe-area-inset-bottom);
    --safe-left: env(safe-area-inset-left);
    --safe-right: env(safe-area-inset-right);
  }
  *{box-sizing:border-box}
  html{ font-size: clamp(15px, 1.6vw + .4rem, 18px); }
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,Arial,sans-serif;
    padding-bottom:max(12px, var(--safe-bottom));
    padding-top:max(8px, var(--safe-top));
  }
  header{ border-bottom:1px solid var(--border); padding:14px 16px }
  .wrap{ max-width:1120px; margin:0 auto; padding:16px }
  h1{ margin:0; font-size:20px; letter-spacing:.3px }
  .grid{ display:grid; gap:12px }
  @media(min-width:1000px){ .grid-2{ grid-template-columns:1.1fr .9fr } }
  .card{ background:var(--card); border:1px solid var(--border); border-radius:14px; padding:14px }
  label{ font-size:13px; color:var(--muted) }
  input,select,textarea{ width:100%; padding:12px; background:transparent; border:1px solid var(--border); border-radius:10px; color:var(--text); font-size:16px }
  button{ background:var(--brand); color:#fff; border:0; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer }
  button.ghost{ background:transparent; color:var(--text); border:1px solid var(--border) }
  small{ color:var(--muted) }
  table{ width:100%; border-collapse:collapse }
  th,td{ border-bottom:1px solid var(--border); padding:8px 6px; text-align:left }
  th{ color:var(--muted); font-weight:600 }
  .right{ text-align:right }
  .pill{ display:inline-flex; gap:8px; align-items:center; border:1px solid var(--border); padding:6px 8px; border-radius:999px; background:transparent }
  .pill.badge-holiday{
    background:rgba(234,179,8,0.16);
    border-color:rgba(202,138,4,0.45);
    color:#facc15;
    font-size:12px;
    letter-spacing:0.01em;
    text-transform:uppercase;
  }
  .pill.toggle-button{
    cursor:pointer;
    transition:background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
  }
  .pill.toggle-button.active{
    background:rgba(59,130,246,0.18);
    border-color:rgba(59,130,246,0.55);
    color:#93c5fd;
  }
  /* Ensure checkboxes render visibly inside pill labels */
  input[type="checkbox"]{ width:auto; height:auto; padding:0; margin:0 4px 0 0; accent-color: var(--brand); }
  .modelMetric{ color:#fbbf24; font-weight:400; }
  #liveModelStrip .pill b{ color:inherit; font-weight:400; }
  #diagnosticsLegend{
    margin-top:6px;
    font-size:0.75em;
    color:#6b7280;
    display:flex;
    gap:12px;
  }
  #diagnosticsLegend span{
    display:flex;
    align-items:center;
    gap:4px;
  }
  #diagnosticsLegend .swatch{
    width:14px; height:14px; border-radius:3px;
    border:1px solid rgba(255,255,255,0.4);
  }
  .legend-swatch{ display:inline-block; width:10px; height:10px; border-radius:2px; margin-right:6px }
  /* ==== Diagnostics table polish ==== */
  .diag-table{
    width:100%;
    border-collapse:separate;
    border-spacing:0;
    background:transparent;
    font-variant-numeric:tabular-nums;
    border-radius:12px;
    overflow:hidden;
    font-size:clamp(.95rem, 2.9vw, 1.05rem);
  }
  .diag-table th,
  .diag-table td{
    padding:10px 12px;
    border-top:1px solid var(--rs-grid);
    line-height:1.3;
  }
  .diag-table thead th{
    background:color-mix(in srgb, var(--rs-cell) 60%, transparent);
    border-top:none;
    text-align:left;
    font-weight:600;
  }
  .diag-table tbody tr:nth-child(odd){
    background:color-mix(in srgb, var(--rs-cell) 40%, transparent);
  }
  @media(prefers-color-scheme:dark){
    .diag-table thead th{ background:var(--rs-cell-dark); }
    .diag-table tbody tr:nth-child(odd){ background:color-mix(in srgb, var(--rs-cell-dark) 55%, transparent); }
    .diag-table th,
    .diag-table td{ border-top:1px solid var(--rs-grid-dark); }
    .diag-table td+td,
    .diag-table th+th{ border-left:1px solid var(--rs-grid-dark); }
  }
  .diag-table td+td,
  .diag-table th+th{
    border-left:1px solid var(--rs-grid);
  }
  .diag-table td{ text-align:right; white-space:nowrap; }
  .diag-table td:first-child,
  .diag-table th:first-child{ text-align:left; }
  .diag-table .text-left{ text-align:left; }
  .notes-cell{
    text-align:justify;
    text-align-last:left;
    text-justify:inter-word;
    hyphens:auto;
    line-height:1.4;
    vertical-align:top;
    white-space:normal;
  }
  .notes-cell p{ margin:0 0 6px 0; }
  .notes-cell p:last-child{ margin-bottom:0; }
  .vac-mark { font-size:0.7em; color:var(--muted); margin-left:2px; }
  .vac-ranges{ margin-top:10px; display:flex; flex-direction:column; gap:6px; }
  .vac-range-item{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:6px 10px; border:1px solid var(--border); border-radius:10px; background:rgba(148,163,184,0.08); font-size:0.9rem; }
  .vac-range-item small{ color:var(--muted); }
  .vac-range-item button{ margin-left:auto; }
  .stat .statValue{ display:block; font-size:18px; font-weight:500; font-variant-numeric:tabular-nums; letter-spacing:-0.02em; }
  .stat .statValue--lg{ font-size:20px; }
  .stat .statValue--sm{ font-size:17px; }
  .stat .statDelta{ font-size:18px; font-weight:600; font-variant-numeric:tabular-nums; letter-spacing:-0.02em; }
  .snapshot-sections{ display:grid; grid-template-columns:repeat(auto-fit, minmax(320px, 1fr)); gap:16px; }
  .snapshot-section{ border:1px solid var(--border); border-radius:14px; padding:14px; background:rgba(148,163,184,0.08); display:flex; flex-direction:column; gap:12px; }
  .fullWidth{ grid-column:1 / -1; }
  .snapshot-section h4{ margin:0 0 10px 0; font-size:13px; font-weight:600; text-transform:uppercase; letter-spacing:0.08em; color:var(--muted); }
  .snapshot-grid{ display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:12px; align-items:stretch; }
  .snapshot-grid .full-span{ grid-column:1 / -1; }
  .snapshot-subgrid{ display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:12px; }
  .pill-row{ display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
  .leaderboard-table{ width:100%; border-collapse:collapse; font-size:13px; }
  .leaderboard-table th, .leaderboard-table td{ padding:6px 8px; border-bottom:1px solid var(--border); text-align:right; }
  .leaderboard-table th:first-child, .leaderboard-table td:first-child{ text-align:left; }
  .leaderboard-table tbody tr:last-child td{ border-bottom:none; }
  .cardSection{ border-top:1px solid var(--border); margin-top:16px; padding-top:12px; }
  .cardSection h4{ margin:0 0 10px 0; font-size:14px; }
  .trip-summary{ font-size:13px; line-height:1.5; }
  .diag-wrap{
    overflow:auto;
    border-radius:12px;
    box-shadow:0 1px 0 rgba(0,0,0,.06);
  }
  .delta{
    display:inline-block;
    min-width:4.5ch;
    text-align:right;
    padding:2px 6px;
    border-radius:999px;
    background:color-mix(in srgb, currentColor 12%, transparent);
    font-variant-numeric:tabular-nums;
    font-size:clamp(1rem, 3.4vw, 1.15rem);
  }
  .delta.pos{ color:var(--rs-pos); }
  .delta.neg{ color:var(--rs-neg); }
  .delta.zero{ color:var(--rs-mute); }
  .delta.outlier{ box-shadow:0 0 0 1.5px currentColor inset; }
  .num, .delta{ font-variant-numeric:tabular-nums; font-size:clamp(1rem, 3.4vw, 1.15rem); }
  .scope-badge{
    display:inline-flex;
    align-items:center;
    gap:.5ch;
    margin-top:6px;
    padding:4px 14px;
    border-radius:999px;
    font-weight:600;
    font-size:.9rem;
    letter-spacing:.02em;
    background:rgba(37,99,235,.18);
    border:1px solid rgba(37,99,235,.42);
    color:#e8f1ff;
    text-shadow:0 1px 1px rgba(0,0,0,.55);
  }
  @media(prefers-color-scheme:light){
    .scope-badge{
      background:rgba(37,99,235,.12);
      border:1px solid rgba(37,99,235,.35);
      color:#1d4ed8;
      text-shadow:none;
    }
  }
  .scope-badge .dot{
    width:.55em;
    height:.55em;
    border-radius:50%;
    background:#2563eb;
  }
  .scope-badge.all .dot{ background:#6b7280; }
  @media (max-width:420px){
    .diag-table th,
    .diag-table td{ padding:12px 12px; }
    .scope-badge{ font-size:.95rem; }
  }
  #diagnosticsLegend{ margin-top:6px; font-size:.75em; color:#6b7280; display:flex; gap:12px; flex-wrap:wrap }
  #diagnosticsLegend span{ display:flex; align-items:center; gap:4px }
  #diagnosticsLegend .swatch{ width:12px; height:12px; border-radius:3px }
  .stat{ display:flex; flex-direction:column; gap:4px; padding:10px; border:1px solid var(--border); border-radius:12px; min-width:140px }
  .up{ color:var(--good) } .down{ color:var(--bad) } .warn{ color:var(--warn) }
  canvas{ background:transparent; border:1px solid var(--border); border-radius:10px; padding:8px; touch-action: manipulation; -webkit-tap-highlight-color: transparent }
  /* Slim sparkline override: no border/padding, minimal height */
  canvas.sparkline{ display:block; width:100%; border:none; padding:0; height:48px; max-height:48px; touch-action: manipulation; -webkit-tap-highlight-color: transparent }
  .sparkline-labels{ color:var(--muted); font-size:12px; margin-top:4px }
  .sparkline-summary{ color:var(--muted); font-size:12px; margin-top:4px }
  .fab{ position:fixed; right:16px; bottom:16px; z-index:10 }
  #diag{ position:sticky; top:0; z-index:999; background:#111; color:#ddd; font:12px/1.35 system-ui; padding:6px 10px; border-bottom:1px solid #222 }
  #diag b{ color:#fff }
  tr.light td{ background:linear-gradient(90deg, rgba(124,227,139,.07), transparent) }
  tr.heavy td{ background:linear-gradient(90deg, rgba(255,143,161,.10), transparent) }
  tr.typical td{ background:linear-gradient(90deg, rgba(255,210,122,.08), transparent) }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
  dialog{ background:var(--card); color:var(--text); border:1px solid var(--border); border-radius:12px; padding:16px }

  /* Visibility + focus upgrades */
  input,select,textarea{
    background:#0b0f15;
    border:1px solid #303643;
    font-size:16px;
    caret-color:var(--brand);
  }
  input:hover,select:hover,textarea:hover{ border-color:#3d4554 }
  input:focus-visible,select:focus-visible,textarea:focus-visible{
    outline:2px solid var(--brand);
    outline-offset:0;
    border-color:var(--brand);
    box-shadow:0 0 0 3px rgba(43,127,255,.25);
    background:#0c1220;
  }
  ::placeholder{ color:#b7beca; opacity:1 }
  .card .grid > div:has(> input:focus-visible),
  .card .grid > div:has(> select:focus-visible),
  .card .grid > div:has(> textarea:focus-visible){
    background:#101726;
    border-radius:10px;
    padding:6px;
    transition:background .15s ease;
  }

  /* Save feedback */
  button.saving{ opacity:.7; cursor:wait }
  @keyframes savedFlash{
    0%{ box-shadow:0 0 0 0 rgba(43,127,255,.6) }
    100%{ box-shadow:0 0 0 14px rgba(43,127,255,0) }
  }
  button.savedFlash{ animation:savedFlash 600ms ease-out }

  /* Clickable results */
  #tbl tbody tr.rowLink{ cursor:pointer }
  #tbl tbody tr.rowLink:hover td{ background:rgba(43,127,255,.06) }
  /* Compact header buttons (e.g., Quick Entry) */
  button.btn-compact{ padding:4px 8px; font-size:12px; border-radius:999px }
</style>
</head>
<body>
<div id="diag">
  ROUTE STATS · Supabase: <b id="dConn">…</b> · Auth: <b id="dAuth">…</b> · Write: <b id="dWrite">—</b>
</div>

<!-- Version tag -->
<div id="verTag" style="position:fixed;top:6px;right:12px;color:#9aa0aa;font-size:11px;z-index:9999;">v—</div>
<!-- USPS Evaluation summary (fixed) -->
<div id="uspsEvalTag" title="Click to edit USPS evaluation in Settings"
     style="position:fixed;top:26px;right:12px;z-index:9999;display:none">
  <span class="pill" style="font-size:11px;line-height:1.2;gap:6px;padding:6px 8px;cursor:pointer">
    <span id="evalRouteLabel">—</span>
    <span id="evalEvalCode" class="muted">—</span>
    <span id="evalBoxes" class="muted">— boxes</span>
    <span id="evalSalary" class="muted">—/yr</span>
    <span id="evalHours" class="muted">—h (— office)</span>
  </span>
</div>

<!-- Live model strip -->
<div id="liveModelStrip" style="display:none;margin:8px 0;gap:8px;flex-wrap:wrap" class="row">
  <span class="pill" title="bp: minutes per parcel predicted by the model"><span class="modelMetric">bp</span>: <span id="lm-bp">—</span> min/parcel</span>
  <span class="pill" title="bl: minutes per letter predicted by the model"><span class="modelMetric">bl</span>: <span id="lm-bl">—</span> min/letter</span>
  <span class="pill" title="Letter weight (bl ÷ bp) used for combined volume"><span class="modelMetric">w</span>: <span id="lm-w">—</span></span>
  <span class="pill" title="Model fit (coefficient of determination)"><span class="modelMetric">R²</span>: <span id="lm-r2">—</span></span>
</div>

<header>
  <div class="wrap row" style="justify-content:space-between;align-items:flex-start;gap:8px;flex-wrap:wrap">
    <!-- CHANGED: dynamic date -->
    <div>
      <h1 style="margin-bottom:4px">📈 ROUTE STATS — Live Dashboard — <span id="headerDate">—</span></h1>
      <div id="modelScopeBadge" class="scope-badge" aria-live="polite"></div>
      <div id="headlineDigest" style="display:none;font-size:13px;color:var(--text);text-align:center;margin-top:6px">—</div>
      <div id="smartSummary" style="display:none;font-size:13px;color:var(--text);text-align:center;margin-top:6px">—</div>
    </div>
    <div class="row">
      <button id="signInBtn" class="ghost">Sign in</button>
      <button id="setPwBtn" class="ghost" title="Set/Change password for the current account">Set password</button>
      <button id="linkBtn" class="ghost">Link devices (magic link)</button>
      <button id="signOut" class="ghost">Sign out</button>
      <button id="btnSettings" class="ghost" title="Toggle feature flags">Settings</button>
      <button id="btnFocusMode" class="ghost" title="Show only snapshot tiles (collapse the rest)" style="display:none">Focus Mode: Off</button>
      <a href="docs/metrics.html" target="_blank" class="ghost" style="text-decoration:none; padding:10px 14px; border:1px solid var(--border); border-radius:10px">Data Sheet</a>
    </div>
  </div>
</header>

<main class="wrap grid grid-2">
  <!-- SNAPSHOT -->
  <section class="card fullWidth" id="snapshotCard">
    <div class="snapshot-sections">
    <div class="snapshot-section">
      <h4>Today</h4>
      <div class="snapshot-grid">
        <div class="stat">
          <small>Expected End (today)</small>
          <span id="expEnd" class="statValue statValue--lg">—</span>
          <small id="expMeta" style="color:var(--muted)">DOW avg —</small>
        </div>
        <div class="stat">
          <small>Volume</small>
          <span id="badgeVolume" class="statValue statValue--lg">—</span>
          <small class="muted">parcels + <span class="modelMetric">w×letters</span> (data-fit)</small>
          <div id="helpVolume" style="display:none;margin-top:4px;font-size:12px;color:var(--muted)">—</div>
          <button id="openVolumeLeaderboard" type="button" class="ghost" style="align-self:flex-start;font-size:12px;padding:4px 8px;">Top days</button>
        </div>
        <div class="stat">
          <small>Route Eff.</small>
          <span id="badgeRouteEff" class="statValue statValue--lg">—</span>
          <small class="muted">vs weekday baseline</small>
          <div id="helpRouteEff" style="display:none;margin-top:4px;font-size:12px;color:var(--muted)">—</div>
        </div>
        <div class="stat">
          <small>Overall</small>
          <span id="badgeOverall" class="statValue statValue--lg">—</span>
          <small class="muted">office + route vs expected</small>
          <div id="helpOverall" style="display:none;margin-top:4px;font-size:12px;color:var(--muted)">—</div>
        </div>
        <div class="stat">
          <small>Today Parcels Δ</small>
          <span id="todayParcelsDelta" class="statDelta">—</span>
          <small class="muted">vs past same weekday (worked)</small>
        </div>
        <div class="stat">
          <small>Today Letters Δ</small>
          <span id="todayLettersDelta" class="statDelta">—</span>
          <small class="muted">vs past same weekday (worked)</small>
        </div>
        <div class="stat">
          <small>Today Office Δ</small>
          <span id="todayOfficeDelta" class="statDelta">—</span>
          <small class="muted">vs past same weekday (worked)</small>
        </div>
        <div class="stat" id="extraTripTodayTile" style="display:none">
          <small>Extra Trip</small>
          <span id="extraTripTodayVal" class="statValue statValue--lg">—</span>
          <small class="muted" id="extraTripTodayMeta">—</small>
        </div>
        <div class="stat" id="todayHourlyTile" style="display:none">
          <small>Running $/h</small>
          <span id="todayHourlyRate" class="statValue statValue--lg">—</span>
          <small class="muted" id="todayHourlyMeta">Includes extra trip payout</small>
        </div>
        <div class="stat full-span" id="todayHeaviness" style="display:none"></div>
      </div>
    </div>

    <div class="snapshot-section">
      <h4>Week & USPS</h4>
      <div class="snapshot-grid">
        <div class="stat" id="tileWkHours" style="cursor:pointer" tabindex="0" title="Click for weekly hours breakdown">
          <small>Hours (week)</small>
          <div><span id="wkHours" class="statValue statValue--lg">—</span> <span id="wkHoursDelta" class="pill">—</span></div>
        </div>
        <div class="stat" id="tileWkParcels" style="cursor:pointer" tabindex="0" title="Click for weekly parcels breakdown">
          <small>Parcels (week)</small>
          <div><span id="wkParcels" class="statValue statValue--lg">—</span> <span id="wkParcelsDelta" class="pill">—</span></div>
        </div>
        <div class="stat" id="tileWkLetters" style="cursor:pointer" tabindex="0" title="Click for weekly letters breakdown">
          <small>Letters (week)</small>
          <div><span id="wkLetters" class="statValue statValue--lg">—</span> <span id="wkLettersDelta" class="pill">—</span></div>
        </div>
        <div class="stat" id="extraMilesWeek">
          <small>Extra trip miles</small>
          <span class="statValue statValue--lg" id="extraMilesWeekVal">—</span>
          <small class="muted">Mon..today total</small>
        </div>
        <div class="stat" id="extraTimeWeek">
          <small>Extra trip time</small>
          <span class="statValue statValue--lg" id="extraTimeWeekVal">—</span>
          <small class="muted">Actual min (Mon..today)</small>
        </div>
        <div class="stat" id="extraPayoutWeek">
          <small>Extra trip payout</small>
          <span class="statValue statValue--lg" id="extraPayoutWeekVal">—</span>
          <small class="muted">Paid time + EMA</small>
        </div>
        <div class="stat" id="tileUspsRouteEff">
          <small>USPS Route Eff.</small>
          <span id="uspsRouteEffVal" class="statValue">—</span>
          <small class="muted">this week vs eval</small>
        </div>
        <div class="stat" id="tileUspsHourly">
          <small>Weekly $/h</small>
          <span id="uspsHourlyRateVal" class="statValue">—</span>
          <small class="muted">4w avg</small>
        </div>
        <div class="stat full-span" id="trendFactors" style="display:none"></div>
        <div class="stat full-span" id="weekHeaviness" style="display:none"></div>
        <div id="trendPillsRow" class="snapshot-subgrid full-span" style="display:none">
          <div class="stat" id="tileAdvHours" style="cursor:pointer" tabindex="0" title="Click for weighted daily hour deltas">
            <small>Weekly Hours Trend</small>
            <div><span id="advHoursTrend" class="pill">—</span></div>
            <small class="muted">day-by-day vs last week</small>
          </div>
          <div class="stat" id="tileAdvParcels" style="cursor:pointer" tabindex="0" title="Click for weighted daily parcel deltas">
            <small>Weekly Parcels Trend</small>
            <div><span id="advParcelsTrend" class="pill">—</span></div>
            <small class="muted">day-by-day vs last week</small>
          </div>
          <div class="stat" id="tileAdvLetters" style="cursor:pointer" tabindex="0" title="Click for weighted daily letter deltas">
            <small>Weekly Letters Trend</small>
            <div><span id="advLettersTrend" class="pill">—</span></div>
            <small class="muted">day-by-day vs last week</small>
          </div>
        </div>
      </div>
    </div>
    </div>

    <!-- Inline details panel for weekly hours breakdown (toggled on click) -->
    <div id="wkHoursDetails" style="display:none;margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px">
      <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <h4 style="margin:0">Weekly Hours Breakdown</h4>
        <button id="closeWkHoursDetails" class="ghost">Close</button>
      </div>
      <small class="muted" style="color:var(--text)">Shows this week (Mon..today) vs last week (Mon..Sun). Δ% compares each weekday and the totals.</small>
      <div id="wkHoursDetailsBody" style="margin-top:8px;overflow:auto;border:1px solid var(--border);border-radius:10px">
        <!-- populated by script -->
      </div>
    </div>
    <!-- Inline details panel for weekly parcels breakdown -->
    <div id="wkParcelsDetails" style="display:none;margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px">
      <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <h4 style="margin:0">Weekly Parcels Breakdown</h4>
        <button id="closeWkParcelsDetails" class="ghost">Close</button>
      </div>
      
      <div id="wkParcelsDetailsBody" style="margin-top:8px;overflow:auto;border:1px solid var(--border);border-radius:10px"></div>
    </div>
    <!-- Inline details panel for weekly letters breakdown -->
    <div id="wkLettersDetails" style="display:none;margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px">
      <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <h4 style="margin:0">Weekly Letters Breakdown</h4>
        <button id="closeWkLettersDetails" class="ghost">Close</button>
      </div>
      
      <div id="wkLettersDetailsBody" style="margin-top:8px;overflow:auto;border:1px solid var(--border);border-radius:10px"></div>
    </div>
    <!-- Inline details panel for advanced Weekly Trend (Hours) -->
    <div id="advHoursDetails" style="display:none;margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px">
      <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <h4 style="margin:0">Weekly Hours Trend — Weighted daily deltas</h4>
        <button id="closeAdvHoursDetails" class="ghost">Close</button>
      </div>
      <small class="muted">Mon..today vs same weekday last week. Uses Weighted average (falls back to Cumulative if needed).</small>
      <div id="advHoursDetailsBody" style="margin-top:8px;overflow:auto;border:1px solid var(--border);border-radius:10px"></div>
    </div>
    <!-- Inline details panel for advanced Weekly Trend (Parcels) -->
    <div id="advParcelsDetails" style="display:none;margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px">
      <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <h4 style="margin:0">Weekly Parcels Trend — Weighted daily deltas</h4>
        <button id="closeAdvParcelsDetails" class="ghost">Close</button>
      </div>
      <small class="muted">Mon..today vs same weekday last week. Uses Weighted average (falls back to Cumulative if needed).</small>
      <div id="advParcelsDetailsBody" style="margin-top:8px;overflow:auto;border:1px solid var(--border);border-radius:10px"></div>
    </div>
    <!-- Inline details panel for advanced Weekly Trend (Letters) -->
    <div id="advLettersDetails" style="display:none;margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px">
      <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <h4 style="margin:0">Weekly Letters Trend — Weighted daily deltas</h4>
        <button id="closeAdvLettersDetails" class="ghost">Close</button>
      </div>
      <small class="muted">Mon..today vs same weekday last week. Uses Weighted average (falls back to Cumulative if needed).</small>
      <div id="advLettersDetailsBody" style="margin-top:8px;overflow:auto;border:1px solid var(--border);border-radius:10px"></div>
    </div>

    <div id="volumeLeaderboard" style="display:none;margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px">
      <div class="row" style="justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <h4 style="margin:0">Top Volume Days</h4>
        <button id="closeVolumeLeaderboard" class="ghost">Close</button>
      </div>
      <small id="volumeLeaderboardNote" class="muted">—</small>
      <div style="margin-top:8px;overflow:auto;border:1px solid var(--border);border-radius:10px">
        <table class="leaderboard-table">
          <thead><tr><th>Date</th><th>Parcels</th><th>Letters</th><th>Volume</th><th>Percentile</th></tr></thead>
          <tbody id="volumeLeaderboardBody"></tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- FORM -->
  <section class="card fullWidth" id="addEntryCard">
    <h3 style="margin:0 0 8px 0">Add Entry</h3>

    <div class="row" style="margin:6px 0 10px 0; gap:8px; flex-wrap:wrap">
      <button id="btnStartNow" class="ghost">Start (now)</button>
      <button id="btnStreetNow" class="ghost">Hit Street (now)</button>
      <button id="btnClockNow" class="ghost">Clock Out (now)</button>
      <!-- Quick actions -->
      <button id="btnEditLast" class="ghost">Edit last entry</button>
      <button id="btnDeleteDay" class="ghost" style="border-color:#ff8fa1;color:#ff8fa1">Delete this day</button>
      <button id="btnUndoDelete" class="ghost" style="display:none">Undo delete</button>
    </div>

    <div class="grid" style="grid-template-columns:repeat(2,1fr);gap:10px">
      <div><label>Date</label><input id="date" type="date"></div>

      <div>
        <label>Route</label>
        <input id="route" type="text" value="R1" readonly>
      </div>

      <div><label>Start (defaults 08:00)</label><div class="row"><input id="start" type="time" value="08:00"><button id="btnStartNow2" class="ghost">Now</button></div></div>
      <div><label>Hit Street</label><div class="row"><input id="departTime" type="time" placeholder="--:--"><button id="btnStreetNow2" class="ghost">Now</button></div></div>

      <div><label>Return (optional)</label><div class="row"><input id="returnTime" type="time" placeholder="--:--"><button id="btnReturnNow" class="ghost">Now</button></div></div>
      <div><label>Clock Out</label><div class="row"><input id="end" type="time" placeholder="--:--"><button id="btnClockNow2" class="ghost">Now</button></div></div>

      <div><label>Parcels</label><input id="parcels" type="number" min="0" value="0"></div>
      <div><label>Letters</label><input id="letters" type="number" min="0" value="0"></div>
      <div><label>Miles</label><input id="miles" type="number" step="0.1" min="0" value="53"></div>

      <div>
        <label>Weather</label>
        <div class="row">
          <select id="weather" style="min-width:160px">
            <option value="">—</option>
            <option>☀️ Sunny</option>
            <option>⛅ Partly Cloudy</option>
            <option>🌧️ Rain</option>
            <option>❄️ Snow</option>
            <option>💨 Windy</option>
            <option>🌫️ Fog</option>
            <option>Other</option>
          </select>
          <select id="temp" title="Temp (°F)" style="min-width:110px">
            <option value="">Temp (°F)</option>
            <option>20</option><option>25</option><option>30</option><option>35</option>
            <option>40</option><option>45</option><option>50</option><option>55</option>
            <option>60</option><option>65</option><option>70</option><option>75</option>
            <option>80</option><option>85</option><option>90</option><option>95</option>
          </select>
        </div>
      </div>

      <div>
        <label>Boxholders</label>
        <select id="boxholders" title="x1 = one boxholder; x2 = two; x3 = three+">
          <option value="">—</option>
          <option value="x1">x1</option>
          <option value="x2">x2</option>
          <option value="x3">x3</option>
        </select>
      </div>

      <div>
        <label>Reason (optional)</label>
        <input id="reasonTag" type="text" placeholder="e.g., Boxholders, Detour, Weather" />
      </div>

      <div><label>Mood</label><select id="mood"><option value="">—</option><option>🔥 dialed in</option><option>🙂 good</option><option>😐 meh</option><option>🥵 cooked</option><option>🌧️ soggy</option><option>🛑 off</option></select></div>
      <div><label>Extra trip miles
        <input id="secondTripMiles" type="number" min="0" step="0.1" placeholder="e.g., 6.5">
      </label></div>
      <div><label>Extra trip time (min)
        <input id="secondTripTime" type="number" min="0" step="1" placeholder="e.g., 45">
      </label></div>
      <input id="secondTripEma" type="hidden">
      <div class="trip-summary" id="secondTripSummary" style="grid-column:1/-1;margin-top:-2px">
        🕒 Paid time: <strong id="secondTripPaid">0</strong> min (2 min/mi)
        · ⏱ Actual: <strong id="secondTripActual">0</strong> min
        · 💸 Reimbursement: $<strong id="secondTripReimburse">0.00</strong>
        · EMA: $<strong id="secondTripEmaRate">0.00</strong>/mi
      </div>
      <small class="muted" style="grid-column:1/-1;margin-top:-6px">Second-trip time is excluded from route efficiency; defaults live under Settings → Extra Trip Defaults and totals roll into weekly tiles.</small>
      <div style="grid-column:1/-1"><label>Notes</label><textarea id="notes" rows="2" placeholder="Anything notable…"></textarea></div>

      <div class="row" style="grid-column:1/-1;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
        <div class="row" style="gap:8px;align-items:center">
          <label class="pill"><input id="offDay" type="checkbox"> Off day</label>
          <label class="pill" title="If an off day is a holiday, the next day's baseline will include two days to avoid skew"><input id="holiday" type="checkbox"> Holiday (observed)</label>
        </div>
        <div class="row"><span class="pill"><small>Office:</small> <b id="officeH">—</b></span><span class="pill"><small>Route:</small> <b id="routeH">—</b></span><span class="pill"><small>Total:</small> <b id="totalH">—</b></span></div>
        <div class="row"><button id="save">Save</button></div>
      </div>
    </div>
  </section>

  <!-- CHARTS -->
  <section class="card" id="dowCard"><h3 style="margin:0 0 8px 0">Average Hours by Weekday</h3><canvas id="dowChart" height="180"></canvas></section>
  <section class="card" id="parcelsOverTimeCard"><h3 style="margin:0 0 8px 0">Parcels Over Time (worked days)</h3><canvas id="parcelsChart" height="180"></canvas></section>
  <section class="card" id="lettersOverTimeCard"><h3 style="margin:0 0 8px 0">Letters Over Time (worked days)</h3><canvas id="lettersChart" height="180"></canvas></section>

  <!-- Quick Filter (Phase 3) -->
  <section class="card" id="quickFilterCard">
    <div class="row" style="justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
      <h3 style="margin:0">Quick Filter</h3>
      <select id="qfSelect" style="min-width:140px">
        <option value="all">All days</option>
        <option value="1">Monday</option>
        <option value="2">Tuesday</option>
        <option value="3">Wednesday</option>
        <option value="4">Thursday</option>
        <option value="5">Friday</option>
        <option value="6">Saturday</option>
        <option value="0">Sunday</option>
      </select>
    </div>
    <div class="row" id="qfStats" style="gap:8px;flex-wrap:wrap;margin-top:8px">
      <!-- pills populated by script -->
    </div>
      <div id="qfViz" style="margin-top:8px">
      <div class="row" id="qfMetrics" style="gap:8px;flex-wrap:wrap;margin-bottom:6px;align-items:center">
        <label class="pill" title="Toggle all metrics on/off"><input id="qfAllMetrics" type="checkbox" checked> All</label>
        <label class="pill"><span class="legend-swatch" style="background: var(--brand)"></span><input id="qfShowParcels" type="checkbox" checked> Parcels</label>
        <label class="pill"><span class="legend-swatch" style="background: var(--warn)"></span><input id="qfShowLetters" type="checkbox" checked> Letters</label>
        <label class="pill"><span class="legend-swatch" style="background: var(--good)"></span><input id="qfShowHours"   type="checkbox" checked> Hours</label>
        <span class="pill" style="gap:6px"><small>Last</small>
          <select id="qfLastN" style="min-width:80px">
            <option value="8">8</option>
            <option value="12" selected>12</option>
            <option value="20">20</option>
          </select>
        </span>
        <label class="pill" title="Show faint 0/50/100 guide when normalized"><input id="qfShowRuler" type="checkbox"> Ruler</label>
        <span id="qfNormBadge" class="pill" style="display:none;border-color:var(--brand);color:var(--brand)" title="Values are normalized (0–100) for comparability">Normalized</span>
        <span id="qfDaysBadge" class="pill" title="Number of filtered days" style="display:none"></span>
      </div>
  <canvas id="qfSpark" class="sparkline" style="height:64px;max-height:64px"></canvas>
  <div id="qfText" class="sparkline-labels">—</div>
  </div>
  </section>

  <!-- Day Compare (experimental) -->
  <section class="card" id="dayCompareCard" style="grid-column:1/-1; display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-start;gap:10px;flex-wrap:wrap">
      <div>
        <h3 style="margin:0 0 6px 0">Day Compare</h3>
        <small class="muted">Pick a day, then compare against last same weekday, weekday baseline, or any prior entry.</small>
      </div>
      <button id="dcToggleRef" class="ghost" type="button" style="display:none">Cycle reference</button>
    </div>
    <div class="row" style="gap:10px;align-items:flex-end;flex-wrap:wrap;margin-top:10px">
      <div style="min-width:220px">
        <label for="dcSubjectSelect">Subject day</label>
        <select id="dcSubjectSelect"></select>
      </div>
      <div style="min-width:220px">
        <label for="dcReferenceMode">Reference</label>
        <select id="dcReferenceMode">
          <option value="last">Last same weekday</option>
          <option value="baseline">Weekday baseline (avg)</option>
          <option value="manual">Pick another day…</option>
        </select>
      </div>
      <div id="dcManualPicker" style="min-width:220px;display:none">
        <label for="dcManualSelect">Reference day</label>
        <select id="dcManualSelect"></select>
      </div>
    </div>
    <div id="dcContent" style="margin-top:16px">
      <div id="dcEmpty" style="color:var(--muted);font-size:14px">Select a worked day to compare.</div>
      <div id="dcCompare" style="display:none">
        <div class="row" style="gap:12px;flex-wrap:wrap">
          <div class="card" style="flex:1;min-width:260px;border:1px solid var(--border);background:rgba(16,20,28,0.6);padding:12px">
            <small class="muted">Subject</small>
            <h4 id="dcSubjectLabel" style="margin:4px 0 8px 0">—</h4>
            <div class="row" style="gap:10px;flex-wrap:wrap" id="dcSubjectPills"></div>
            <div id="dcSubjectNotes" style="margin-top:10px;font-size:13px;color:var(--muted)"></div>
          </div>
          <div class="card" style="flex:1;min-width:260px;border:1px solid var(--border);background:rgba(16,20,28,0.6);padding:12px">
            <small class="muted">Reference</small>
            <h4 id="dcReferenceLabel" style="margin:4px 0 8px 0">—</h4>
            <div class="row" style="gap:10px;flex-wrap:wrap" id="dcReferencePills"></div>
            <div id="dcReferenceNotes" style="margin-top:10px;font-size:13px;color:var(--muted)"></div>
          </div>
        </div>
        <div class="card" style="margin-top:12px;border:1px solid var(--border);background:rgba(16,20,28,0.45);padding:12px">
          <small class="muted">Delta focus</small>
          <div class="row" id="dcHighlights" style="gap:10px;flex-wrap:wrap;margin-top:6px"></div>
          <div id="dcReasoning" style="margin-top:10px;color:var(--muted);font-size:13px"></div>
        </div>
        <div class="card" style="margin-top:12px;border:1px solid var(--border);background:transparent;padding:12px">
          <table style="width:100%;border-collapse:collapse;font-size:14px">
            <thead>
              <tr style="color:var(--muted);text-transform:uppercase;font-size:12px">
                <th style="padding:6px 4px;text-align:left">Metric</th>
                <th style="padding:6px 4px;text-align:right">Subject</th>
                <th style="padding:6px 4px;text-align:right">Reference</th>
                <th style="padding:6px 4px;text-align:right">Δ</th>
              </tr>
            </thead>
            <tbody id="dcTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </section>

  <!-- Mix Compare (Baseline-aware) -->
  <section class="card" id="mixVizCard" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
      <h3 style="margin:0">Weekly Compare</h3>
      <button id="mixCompareBtn" class="ghost" type="button">Details</button>
    </div>
    <div class="sparkline-labels">This week vs last (Mon..today vs last Mon..Sun)</div>
    <canvas id="weekOverlay" class="sparkline" style="margin-top:4px;height:72px;max-height:72px"></canvas>
    <div id="mixText" class="sparkline-labels">—</div>
    <div id="mixEff" class="sparkline-labels">—</div>
    <div id="mixCulprits" class="sparkline-labels">—</div>
    <div class="sparkline-labels">Efficiency (min/vol) — lower is better</div>
    <canvas id="effOverlay" class="sparkline" style="margin-top:4px;height:64px;max-height:64px"></canvas>
    <div id="mixCompareDetails" class="sparkline-summary" style="display:none; margin-top:6px">—</div>
    <canvas id="mixDrift" class="sparkline" style="margin-top:8px"></canvas>
    <div id="mixDriftText" class="sparkline-labels">—</div>
  </section>

  <!-- Office Time Compare -->
  <section class="card" id="officeCompareCard" style="grid-column:1/-1; display:none">
    <h3 style="margin:0 0 6px 0">Office Time Compare</h3>
    <div class="sparkline-labels">This week (Mon..today) vs last week (Mon..Sun)</div>
    <canvas id="officeOverlay" class="sparkline" style="margin-top:4px;height:72px;max-height:72px"></canvas>
    <div id="officeSummary" class="sparkline-labels">—</div>
  </section>

  

  <!-- Diagnostics: Volume→Time model & outliers -->
  <section class="card" id="diagnosticsCard" style="grid-column:1/-1; display:none">
    <button id="toggleDiagDetails" class="ghost" type="button" style="all:unset; display:block; width:100%; cursor:pointer;">
      <div class="row" style="justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
        <h3 style="margin:0">Diagnostics — Volume→Time Model</h3>
        <div class="row" style="gap:8px;align-items:center">
          <span id="diagModelBadge" class="pill" title="Minutes per unit (fit from last ~120 worked days)">—</span>
          <span class="pill" aria-hidden="true" style="padding:4px 10px; font-size:0.85rem;">Details</span>
        </div>
      </div>
    </button>
    <div class="sparkline-labels" id="diagSummary">—</div>
    <div class="row" id="diagWeightControls" style="gap:8px;flex-wrap:wrap;margin-top:6px;align-items:center">
      <button id="diagHolidayWeightBtn" type="button" class="pill toggle-button ghost">Downweight holiday catch-up</button>
      <small class="muted" id="diagWeightNote">—</small>
      <button id="diagManageDismissed" type="button" class="ghost" style="font-size:12px;">Manage dismissed</button>
    </div>
    <div id="diagDetails" style="display:none;margin-top:8px">
      <small class="muted">Top residual days (|actual − predicted|). Helps spot non-volume causes: detours, weather, boxholders, etc.</small>
      <div class="diag-wrap" style="margin-top:8px;border:1px solid var(--border);border-radius:12px">
        <table class="diag-table" style="font-size:14px">
          <thead>
            <tr style="color:var(--muted);text-transform:uppercase;font-size:12px">
              <th>Date</th>
              <th>Parcels</th>
              <th>Letters</th>
              <th>Expected h</th>
              <th>Actual h</th>
              <th>Δ Route Time</th>
              <th>Box H</th>
              <th>Wx</th>
              <th>Notes</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="diagTableBody"></tbody>
        </table>
      </div>
      <div id="diagnosticsLegend">
        <span><span class="swatch" style="background:rgba(22,101,52,0.25)"></span> Faster than predicted</span>
        <span><span class="swatch" style="background:rgba(153,27,27,0.25)"></span> Slower than predicted</span>
        <span><span class="swatch" style="background:rgba(107,114,128,0.20)"></span> Near expected</span>
        <span><span class="swatch" style="background:rgba(250,204,21,0.35);border-color:rgba(202,138,4,0.55)"></span> Holiday catch-up</span>
      </div>
    </div>
  </section>

  <!-- Monthly Glance (preview) — behind feature flag -->
  <section class="card" id="monthlyGlanceCard" style="grid-column:1/-1; display:none">
    <h3 style="margin:0 0 8px 0">Monthly Glance (preview)</h3>
    <small class="muted">Last 4 weeks (Mon..Sun). Charts render when available; shows text fallback otherwise.</small>
    <div class="grid" style="margin-top:8px; gap:8px">
      <div>
        <label>Hours</label>
        <div id="mgHours" class="row" style="color:var(--muted)">—</div>
      </div>
      <div>
        <label>Parcels</label>
        <div id="mgParcels" class="row" style="color:var(--muted)">—</div>
      </div>
      <div>
        <label>Letters</label>
        <div id="mgLetters" class="row" style="color:var(--muted)">—</div>
      </div>
    </div>
  </section>

  <!-- TABLE -->
  <section class="card" id="recentEntriesCard" style="grid-column:1/-1">
    <div class="row" style="justify-content:space-between;gap:10px;flex-wrap:wrap">
      <h3 style="margin:0">Recent Entries</h3>
      <div class="row" style="gap:8px">
        <input id="searchBox" type="search" placeholder="Search date, mood, weather, notes…" style="min-width:240px">
        <button id="exportCsv" class="ghost">Export CSV (All)</button>
        <button id="exportCsvFiltered" class="ghost">Export CSV (Filtered)</button>
        <input id="importFile" type="file" accept=".csv,text/csv" style="display:none">
        <button id="importCsv" class="ghost">Import CSV</button>
        <button id="showUid" class="ghost" title="Show current user id">Show UID</button>
      </div>
    </div>
    <div style="max-height:360px;overflow:auto;border:1px solid var(--border);border-radius:10px">
      <table id="tbl"><thead><tr>
        <th>Date</th><th>Route</th><th>Status</th><th class="right">Office (h)</th><th class="right">Route (h)</th><th class="right">Total (h)</th><th class="right">Parcels</th><th class="right">Letters</th><th class="right">Miles</th><th>Weather</th><th>Δ</th>
      </tr></thead><tbody></tbody></table>
    </div>
  </section>
</main>

<!-- Magic link dialog -->
<dialog id="linkDlg">
  <form method="dialog" class="grid" style="min-width:320px;gap:10px">
    <h3 style="margin:0">Link devices</h3>
    <small>Enter your email, then tap the magic link in your inbox on each device.</small>
    <input id="email" type="email" placeholder="you@example.com" required>
    <div class="row" style="justify-content:flex-end;gap:8px"><button class="ghost" value="cancel">Cancel</button><button id="sendLink">Send link</button></div>
  </form>
</dialog>

<!-- Email + Password dialog -->
<dialog id="pwDlg">
  <form method="dialog" class="grid" style="min-width:320px;gap:10px">
    <h3 style="margin:0">Sign in</h3>
    <input id="loginEmail" type="email" placeholder="Email" autocomplete="username" required>
    <input id="loginPass"  type="password" placeholder="Password" autocomplete="current-password" required>
    <div class="row" style="justify-content:flex-end;gap:8px">
      <button class="ghost" value="cancel">Cancel</button>
      <button id="doLogin">Sign In</button>
      <button id="doSignup" class="ghost" type="button" title="Create a new account">Create Account</button>
    </div>
    <small id="authMsg"></small>
  </form>
</dialog>

<!-- NEW: Set Password dialog -->
<dialog id="setPwDlg">
  <form method="dialog" class="grid" style="min-width:320px;gap:10px">
    <h3 style="margin:0">Set a new password</h3>
    <input id="newPass"  type="password" placeholder="New password (6+ chars)" required>
    <input id="newPass2" type="password" placeholder="Confirm password" required>
    <div class="row" style="justify-content:flex-end;gap:8px">
      <button class="ghost" value="cancel">Cancel</button>
      <button id="doSetPw">Save</button>
    </div>
    <small id="setPwMsg"></small>
  </form>
</dialog>

<!-- Settings / Feature Flags dialog -->
  <dialog id="settingsDlg">
  <form method="dialog" class="grid" style="min-width:320px;gap:10px">
    <h3 style="margin:0">Settings</h3>
    <label class="row" style="justify-content:space-between;align-items:center;gap:12px">
      <span>Model scope</span>
      <select id="modelScope" style="min-width:160px">
        <option value="rolling">Rolling (120 days)</option>
        <option value="all">All-time</option>
      </select>
    </label>
    <!-- Feature flags -->
    <label class="pill"><input id="flagWeekdayTicks" type="checkbox"> Show weekday + short date on line charts</label>
    <label class="pill"><input id="flagProgressivePills" type="checkbox"> Progressive color pills for deltas</label>
    <label class="pill"><input id="flagMonthlyGlance" type="checkbox"> Monthly Glance (preview): 4-week stacked sparklines</label>
    <label class="pill"><input id="flagHolidayAdjust" type="checkbox"> Holiday adjustments (carry Monday into Tuesday)
    </label>
    <label class="pill"><input id="flagTrendPills" type="checkbox"> Show Weekly Trend pills (power users)</label>
    <label class="pill"><input id="flagSameRangeTotals" type="checkbox"> Compare weekly totals: Mon..today vs last Mon..today</label>
    <label class="pill"><input id="flagHeadlineDigest" type="checkbox"> Show headline digest (Wed evenings)</label>
    <label class="pill"><input id="flagSmartSummary" type="checkbox"> Smart summary (rule-based)</label>
    
    <label class="pill"><input id="flagBaselineCompare" type="checkbox"> Use baseline-normalized compare (2-week weekday avg)</label>
    <label class="pill"><input id="flagCollapsedUi" type="checkbox"> Collapsed dashboard (experimental)</label>
    <label class="pill"><input id="flagQuickEntry" type="checkbox"> Quick Entry (experimental)</label>
    <label class="pill"><input id="flagUspsEval" type="checkbox"> Show USPS Evaluation summary (fixed tag)</label>

    <!-- USPS Evaluation configuration -->
    <div style="border-top:1px solid var(--border);padding-top:8px;margin-top:4px">
      <h4 style="margin:0 0 6px 0">USPS Evaluation</h4>
      <small class="muted">Used for comparison metrics; stored locally.</small>
      <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
        <div>
          <label>Route label</label>
          <input id="evalRouteId" placeholder="e.g., R1" />
        </div>
        <div>
          <label>Evaluation code</label>
          <input id="evalCode" placeholder="e.g., 44K" />
        </div>
        <div>
          <label>Boxes (deliveries)</label>
          <input id="evalBoxesIn" type="number" min="0" step="1" placeholder="e.g., 670" />
        </div>
        <div>
          <label>Stops</label>
          <input id="evalStopsIn" type="number" min="0" step="1" placeholder="optional" />
        </div>
        <div>
          <label>Expected hours/day</label>
          <input id="evalHoursIn" type="number" min="0" step="0.1" placeholder="e.g., 9.4" />
        </div>
        <div>
          <label>Expected office hours/day</label>
          <input id="evalOfficeHoursIn" type="number" min="0" step="0.1" placeholder="e.g., 2.0" />
        </div>
        <div>
          <label>Annual salary ($)</label>
          <input id="evalSalaryIn" type="number" min="0" step="100" placeholder="e.g., 68000" />
        </div>
      </div>
    </div>


    <!-- Vacation Mode configuration -->
    <div style="border-top:1px solid var(--border);padding-top:8px;margin-top:4px">
      <h4 style="margin:0 0 6px 0">Vacation Mode</h4>
      <small class="muted">Exclude entries in a date range from all metrics.</small>
      <div class="row" style="gap:8px;margin-top:8px;flex-wrap:wrap;align-items:center">
        <span class="pill" style="gap:6px"><small>From</small> <input id="vacFrom" type="date"></span>
        <span class="pill" style="gap:6px"><small>To</small> <input id="vacTo" type="date"></span>
        <button id="vacAdd" class="ghost" type="button">Add Range</button>
      </div>
      <div id="vacRanges" class="vac-ranges"></div>
    </div>
    <div class="row" style="justify-content:flex-end;gap:8px">
      <button class="ghost" value="cancel">Close</button>
      <button id="saveSettings">Save</button>
    </div>
    <div style="border-top:1px solid var(--border);padding-top:8px;margin-top:8px">
      <h4 style="margin:0 0 6px 0">Extra Trip Defaults</h4>
      <label class="pill">EMA rate ($/mi)
        <input id="settingsEmaRate" type="number" min="0" step="0.01" style="margin-left:6px; width:120px">
      </label>
    </div>
    <div style="border-top:1px solid var(--border);padding-top:8px;margin-top:8px">
      <small class="muted">Maintenance</small>
      <div class="row" style="gap:8px;margin-top:6px">
        <button id="forceRefreshBtn" class="ghost" title="Force update service worker and clear caches">Force Refresh (update + clear cache)</button>
      </div>
      <small class="muted">Use if updates don’t appear due to caching.</small>
    </div>
    <small class="muted">Flags are stored locally (this device only).</small>
  </form>
</dialog>

<button class="fab" id="fab">+ Add Entry</button>

<!-- Prefer local vendored libraries; fall back to CDN -->
<script src="vendor/luxon.min.js"></script>
<script src="vendor/chart.umd.js"></script>
<script src="vendor/supabase.js"></script>
<script src="https://unpkg.com/luxon@3/build/global/luxon.min.js"></script>
<!-- Chart.js intentionally not loaded statically to avoid parse errors on blocked/truncated networks. Charts are optional. -->
<script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
<script>
  // If libs failed to load, show a clear banner with next step
  (function(){
    function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
    ready(function(){
      var missingCore=[]; if(!window.luxon) missingCore.push('Luxon'); if(!window.supabase) missingCore.push('Supabase');
      if(missingCore.length){
        var div=document.createElement('div');
        div.style.cssText='position:fixed;left:0;right:0;bottom:0;background:#c62828;color:#fff;padding:10px 14px;z-index:99999;font:14px/1.4 system-ui';
        div.textContent='Missing libraries: '+missingCore.join(', ')+'. Run "Fetch Vendor Libraries.command" to download local copies, then reload.';
        document.body.appendChild(div);
      }
      if(!window.Chart){
        console.warn('Chart.js missing — charts disabled. Everything else should work.');
      }
    });
  })();
  </script>
<script>
  // Global error handler to surface issues in the UI
  (function(){
    window.addEventListener('error', function(e){
      try{
        var div=document.createElement('div');
        div.style.cssText='position:fixed;left:0;right:0;top:0;background:#b00020;color:#fff;padding:10px 14px;z-index:100000;font:13px/1.4 system-ui';
        var loc = '';
        if (e && (e.filename || e.lineno)) {
          loc = ' (' + (e.filename||'inline') + ':' + (e.lineno||'?') + ':' + (e.colno||'?') + ')';
        }
        div.textContent='JavaScript error: ' + (e && e.message ? e.message : 'unknown') + loc;
        document.body.appendChild(div);
        console.error('[RouteStats] error', e);
      }catch(_){ /* ignore */ }
    }, true);
  })();
</script>
<script>
  // ==== SUPABASE CONFIG ====
  console.log('[RouteStats] boot start');
  const SUPABASE_URL  = 'https://ouwkdtiixkaydrtfdhnh.supabase.co';
  const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im91d2tkdGlpeGtheWRydGZkaG5oIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMDc0NDksImV4cCI6MjA3MDU4MzQ0OX0.KI-dYG5_A8jvPEHSog3wlnLbIGYIHQR_4ztXHL2SzIg';
  const ZONE = 'America/Detroit';

  // === Feature Flags (localStorage) ===
  const FLAG_KEY = 'routeStats.flags.v1';
  const EVAL_KEY = 'routeStats.uspsEval.v1';
  const VACAY_KEY = 'routeStats.vacation.v1';
  const BASELINE_KEY = 'routeStats.baseline.v1';
  const MODEL_SCOPE_KEY = 'routeStats.modelScope';
  const DateTime = luxon.DateTime;
  function loadFlags(){
    try{ return Object.assign({ weekdayTicks:true, progressivePills:false, monthlyGlance:true, holidayAdjustments:true, trendPills:false, sameRangeTotals:true, quickFilter:true, headlineDigest:false, smartSummary:true, mixViz:true, baselineCompare:true, collapsedUi:false, focusMode:false, quickEntry:false, uspsEval:true, dayCompare:true }, JSON.parse(localStorage.getItem(FLAG_KEY)||'{}')); }
    catch(_){ return { weekdayTicks:true, progressivePills:false, monthlyGlance:true, holidayAdjustments:true, trendPills:false, sameRangeTotals:true, quickFilter:true, headlineDigest:false, smartSummary:true, mixViz:true, baselineCompare:true, collapsedUi:false, focusMode:false, quickEntry:false, uspsEval:true, dayCompare:true }; }
  }
  function loadEval(){
    try{
      return Object.assign({ routeId:'R1', evalCode:'44K', boxes:670, stops:null, hoursPerDay:9.4, officeHoursPerDay:2.0, annualSalary:68000 }, JSON.parse(localStorage.getItem(EVAL_KEY)||'{}'));
    }catch(_){
      return { routeId:'R1', evalCode:'44K', boxes:670, stops:null, hoursPerDay:9.4, officeHoursPerDay:2.0, annualSalary:68000 };
    }
  }
  function saveEval(cfg){ localStorage.setItem(EVAL_KEY, JSON.stringify(cfg||{})); }
  let USPS_EVAL = loadEval();

  // Vacation Mode config
  function loadVacation(){
    try{
      const v = JSON.parse(localStorage.getItem(VACAY_KEY)||'{}');
      const ranges = Array.isArray(v?.ranges) ? v.ranges : [];
      return { ranges: ranges.filter(r => r?.from && r?.to) };
    }catch(_){ return { ranges: [] }; }
  }
  function saveVacation(cfg){
    try{ localStorage.setItem(VACAY_KEY, JSON.stringify({ ranges: cfg.ranges || [] })); }catch(_){ }
  }
  let VACATION = loadVacation();
  if (VACATION && Array.isArray(VACATION.ranges)){
    const normalized = normalizeRanges(VACATION.ranges);
    if (normalized.length !== VACATION.ranges.length || normalized.some((r,i)=> r.from!==VACATION.ranges[i]?.from || r.to!==VACATION.ranges[i]?.to)){
      VACATION = { ranges: normalized };
      saveVacation(VACATION);
    }
  }

  function normalizeRanges(ranges){
    try{
      const parse = iso => DateTime.fromISO(iso, {zone: ZONE}).startOf('day');
      const items = (ranges||[])
        .map(r => ({ from: r.from, to: r.to }))
        .filter(r => r.from && r.to)
        .map(r => ({ a: parse(r.from), b: DateTime.fromISO(r.to, {zone: ZONE}).endOf('day') }))
        .sort((x,y) => x.a.toMillis() - y.a.toMillis());
      const merged = [];
      for (const it of items){
        if (!merged.length) { merged.push({ ...it }); continue; }
        const last = merged[merged.length-1];
        if (it.a <= last.b.plus({ days: 0 })){
          if (it.b > last.b) last.b = it.b;
        } else {
          merged.push({ ...it });
        }
      }
      return merged.map(x => ({ from: x.a.toISODate(), to: x.b.toISODate() }));
    }catch(_){ return ranges || []; }
  }

  function addVacationRange(fromIso, toIso){
    if (!fromIso || !toIso) return;
    const next = { ranges: [...(VACATION?.ranges || []), { from: fromIso, to: toIso }] };
    next.ranges = normalizeRanges(next.ranges);
    VACATION = next;
    saveVacation(VACATION);
  }

  function removeVacationRange(index){
    const ranges = Array.isArray(VACATION?.ranges) ? [...VACATION.ranges] : [];
    if (index < 0 || index >= ranges.length) return;
    ranges.splice(index, 1);
    VACATION = { ranges: normalizeRanges(ranges) };
    saveVacation(VACATION);
  }

  function listVacationRanges(){
    const cfg = VACATION || loadVacation();
    return Array.isArray(cfg?.ranges) ? cfg.ranges : [];
  }

  function renderVacationRanges(){
    const container = document.getElementById('vacRanges');
    if (!container) return;
    const ranges = listVacationRanges();
    if (!ranges.length){
      container.innerHTML = '<small class="muted">No vacation ranges saved.</small>';
      return;
    }
    const rows = ranges.map((r, idx)=>{
      try{
        const from = DateTime.fromISO(r.from, { zone: ZONE });
        const to   = DateTime.fromISO(r.to,   { zone: ZONE });
        const days = Math.max(1, Math.round(to.endOf('day').diff(from.startOf('day'), 'days').days + 1));
        const label = `${from.toFormat('LLL dd, yyyy')} → ${to.toFormat('LLL dd, yyyy')}`;
        return `<div class="vac-range-item"><div><strong>${label}</strong><br><small>${days} day${days===1?'':'s'}</small></div><button class="ghost vac-remove" type="button" data-index="${idx}">Remove</button></div>`;
      }catch(_){
        return `<div class="vac-range-item"><div><strong>${r.from} → ${r.to}</strong></div><button class="ghost vac-remove" type="button" data-index="${idx}">Remove</button></div>`;
      }
    }).join('');
    container.innerHTML = rows;
  }

  function dateInRangeISO(iso, fromIso, toIso){
    try{
      if (!iso || !fromIso || !toIso) return false;
      const d = DateTime.fromISO(iso, {zone:ZONE}).startOf('day');
      const a = DateTime.fromISO(fromIso, {zone:ZONE}).startOf('day');
      const b = DateTime.fromISO(toIso,   {zone:ZONE}).endOf('day');
      return d >= a && d <= b;
    }catch(_){ return false; }
  }
  function isVacationDate(iso){
    try{
      const cfg = VACATION || loadVacation();
      if (!cfg || !Array.isArray(cfg.ranges)) return false;
      return cfg.ranges.some(r=> dateInRangeISO(iso, r.from, r.to));
    }catch(_){ return false; }
  }
  function filterRowsForView(rows){
    try{
      const cfg = VACATION || loadVacation();
      if (!cfg || !Array.isArray(cfg.ranges) || !cfg.ranges.length) return rows||[];
      return (rows||[]).filter(r=> !isVacationDate(r.work_date));
    }catch(_){ return rows||[]; }
  }

  // Weekly baselines (frozen per week): average of previous 2 completed weeks per weekday
  function ensureWeeklyBaselines(rows){
    try{
      const now = DateTime.now().setZone(ZONE);
      const weekStartIso = startOfWeekMonday(now).toISODate();
      const savedRaw = localStorage.getItem(BASELINE_KEY);
      if (savedRaw){
        const saved = JSON.parse(savedRaw);
        if (saved && saved.weekStart === weekStartIso) return saved;
      }
      const startLast = startOfWeekMonday(now.minus({weeks:1}));
      const endLast   = endOfWeekSunday(now.minus({weeks:1}));
      const startPrev = startOfWeekMonday(now.minus({weeks:2}));
      const endPrev   = endOfWeekSunday(now.minus({weeks:2}));
      const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
      const worked = rows.filter(r=> r.status!=='off');
      const W1 = worked.filter(r=> inRange(r,startLast,endLast));
      const W2 = worked.filter(r=> inRange(r,startPrev,endPrev));
      const byW = (arr,fn)=>{
        const out = Array.from({length:7},()=>[]);
        arr.forEach(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; out[idx].push(fn(r)||0); });
        return out;
      };
      const pW1 = byW(W1, r=> +r.parcels||0), pW2 = byW(W2, r=> +r.parcels||0);
      const lW1 = byW(W1, r=> +r.letters||0), lW2 = byW(W2, r=> +r.letters||0);
      const mean = arr=> arr.length? (arr.reduce((a,b)=>a+b,0)/arr.length) : null;
      const parcels = Array.from({length:7},(_,i)=> mean([...(pW1[i]||[]), ...(pW2[i]||[])]));
      const letters = Array.from({length:7},(_,i)=> mean([...(lW1[i]||[]), ...(lW2[i]||[])]));
      const snap = { weekStart: weekStartIso, parcels, letters };
      localStorage.setItem(BASELINE_KEY, JSON.stringify(snap));
      return snap;
    }catch(_){ return null; }
  }
  function getWeeklyBaselines(){
    try{ return JSON.parse(localStorage.getItem(BASELINE_KEY)||'null'); }catch(_){ return null; }
  }

  // Anchor baselines (on the fly): median of last N completed weeks per weekday (default 8)
  function computeAnchorBaselines(rows, weeks=8){
    try{
      const now = DateTime.now().setZone(ZONE);
      const worked = rows.filter(r=> r.status!=='off');
      // Collect per-week per-weekday values for parcels/letters across last N completed weeks
      const weeksArr = [];
      for (let w=1; w<=weeks; w++){
        const s = startOfWeekMonday(now.minus({weeks:w}));
        const e = endOfWeekSunday(now.minus({weeks:w}));
        weeksArr.push({s,e});
      }
      const perW = (fn)=>{
        const arrs = Array.from({length:7},()=>[]);
        for (const wk of weeksArr){
          const set = worked.filter(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=wk.s && d<=wk.e; });
          const tmp = Array.from({length:7},()=>0);
          set.forEach(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; tmp[idx]+= (fn(r)||0); });
          for (let i=0;i<7;i++) arrs[i].push(tmp[i]);
        }
        // median per weekday
        const med = arrs.map(a=>{
          const b=[...a].sort((x,y)=>x-y); const n=b.length; if(!n) return null; const mid=Math.floor(n/2);
          return n%2? b[mid] : (b[mid-1]+b[mid])/2;
        });
        return med;
      };
      return {
        parcels: perW(r=> +r.parcels||0),
        letters: perW(r=> +r.letters||0)
      };
    }catch(_){ return null; }
  }
  function saveFlags(f){ localStorage.setItem(FLAG_KEY, JSON.stringify(f)); }
  let FLAGS = loadFlags();

  // === Helpers ===
  const $ = id => document.getElementById(id);
  const dConn=$('dConn'), dAuth=$('dAuth'), dWrite=$('dWrite');

  function updateModelScopeBadge(){
    const el = document.getElementById('modelScopeBadge');
    if (!el) return;
    const scope = getModelScope();
    const isRolling = scope !== 'all';
    el.classList.toggle('all', !isRolling);
    el.innerHTML = `<span class="dot" aria-hidden="true"></span>${isRolling ? 'Rolling · 120d' : 'All-time'}`;
  }

  function getModelScope(){
    try{
      const v = localStorage.getItem(MODEL_SCOPE_KEY);
      return (v === 'all' || v === 'rolling') ? v : 'rolling';
    }catch(_){
      return 'rolling';
    }
  }
  function setModelScope(v){
    try{ localStorage.setItem(MODEL_SCOPE_KEY, v); }catch(_){ }
  }
  function rowsForModelScope(allRows){
    const rows = Array.isArray(allRows) ? allRows : [];
    const scope = getModelScope();
    if (scope !== 'rolling') return rows;
    const cutoff = DateTime.now().setZone(ZONE).minus({ days:120 }).startOf('day');
    return rows.filter(r=>{
      try{
        if (!r || !r.work_date) return false;
        const d = DateTime.fromISO(r.work_date, { zone: ZONE });
        return d >= cutoff;
      }catch(_){ return false; }
    });
  }
  (function initModelScopeUI(){
    const el = document.getElementById('modelScope');
    if (!el) return;
    el.value = getModelScope();
    el.addEventListener('change', ()=>{
      setModelScope(el.value);
      updateModelScopeBadge();
      rebuildAll();
    });
  })();

  // NEW: set live header date + version tag
  (function(){
    const d = DateTime.now().setZone(ZONE);
    const el = document.getElementById('headerDate');
    if (el) el.textContent = d.toFormat('MMM d, yyyy');
    const ver = document.getElementById('verTag');
    if (ver) ver.textContent = 'v' + d.toFormat('yyyy-MM-dd');
    updateModelScopeBadge();
  })();

  function renderUspsEvalTag(){
    try{
      const tag = document.getElementById('uspsEvalTag'); if (!tag) return;
      if (!FLAGS.uspsEval){ tag.style.display='none'; return; }
      const cfg = USPS_EVAL || loadEval();
      $('evalRouteLabel').textContent = cfg.routeId || '—';
      $('evalEvalCode').textContent = cfg.evalCode || '—';
      $('evalBoxes').textContent = (cfg.boxes!=null? cfg.boxes : '—') + ' boxes';
      $('evalSalary').textContent = (cfg.annualSalary!=null? ('$'+Number(cfg.annualSalary).toLocaleString()) : '—') + '/yr';
      const hp = (cfg.hoursPerDay!=null? cfg.hoursPerDay : '—');
      const oh = (cfg.officeHoursPerDay!=null? cfg.officeHoursPerDay : '—');
      $('evalHours').textContent = `${hp}h (${oh} office)`;
      tag.style.display='block';
      tag.onclick = ()=> document.getElementById('btnSettings')?.click();
    }catch(_){ /* ignore */ }
  }
  // initial render
  renderUspsEvalTag();
  renderVacationRanges();

  function todayStr(){ return DateTime.now().setZone(ZONE).toISODate(); }
  function hhmmNow(){ const d = DateTime.now().setZone(ZONE); return `${String(d.hour).padStart(2,'0')}:${String(d.minute).padStart(2,'0')}`; }
  function dowIndex(dateStr){ return DateTime.fromFormat(dateStr,'yyyy-MM-dd',{zone:ZONE}).weekday % 7; }
  function startOfWeekMonday(dt){ const w = dt.weekday; const shift = (w+6)%7; return dt.startOf('day').minus({days:shift}); }
  function endOfWeekSunday(dt){ return startOfWeekMonday(dt).plus({days:6}).endOf('day'); }
  function getLastNonEmptyWeek(rows, now, { excludeVacation = true } = {}){
    const worked = (rows || []).filter(r => (+r.hours || 0) > 0);
    const weeksToScan = 12;
    const inRange = (r, from, to) => {
      const d = luxon.DateTime.fromISO(r.work_date, { zone: ZONE });
      return d >= from && d <= to;
    };
    for (let w = 1; w <= weeksToScan; w++){
      const start = startOfWeekMonday(now.minus({ weeks: w }));
      const end   = endOfWeekSunday(now.minus({ weeks: w }));
      const bucket = worked.filter(r => inRange(r, start, end) && (!excludeVacation || !isVacationDate(r.work_date)));
      if (bucket.length) return { start, end, rows: bucket };
    }
    const fallbackStart = startOfWeekMonday(now.minus({ weeks: 1 }));
    const fallbackEnd   = endOfWeekSunday(now.minus({ weeks: 1 }));
    return {
      start: fallbackStart,
      end: fallbackEnd,
      rows: worked.filter(r => inRange(r, fallbackStart, fallbackEnd))
    };
  }

  function vacMark(iso){
    return (iso && isVacationDate(iso)) ? '<sup class="vac-mark" title="Vacation day">v</sup>' : '';
  }

  function vacGlyph(iso){
    return (iso && isVacationDate(iso)) ? ' (v)' : '';
  }

  function isHolidayMarked(row){
    if (!row) return false;
    const text = String(row.weather_json || '');
    return /\bHoliday\b/i.test(text);
  }

  function ensurePostHolidayTags(rows){
    if (!Array.isArray(rows)) return rows;
    try{
      const holidayOff = new Set(
        rows
          .filter(r => r && r.status === 'off' && isHolidayMarked(r))
          .map(r => r.work_date)
          .filter(Boolean)
      );

      const sorted = [...rows].filter(r => r && r.work_date).sort((a,b)=> a.work_date.localeCompare(b.work_date));
      const history = Array.from({ length: 7 }, () => ({ count:0, parcels:0, letters:0, routeMinutes:0 }));

      sorted.forEach(r => {
        try{
          if (!r || r.status === 'off') return;
          const dt = DateTime.fromISO(r.work_date, { zone: ZONE });
          if (!dt.isValid) return;
          const dow = dt.weekday % 7;
          const hist = history[dow];
          const baselineParcels = hist.count ? hist.parcels / hist.count : null;
          const baselineLetters = hist.count ? hist.letters / hist.count : null;
          const baselineRoute = hist.count ? hist.routeMinutes / hist.count : null;

          const parcels = +r.parcels || 0;
          const letters = +r.letters || 0;
          const routeMinutes = routeAdjustedMinutes(r);

          const prevIso = dt.minus({ days: 1 }).toISODate();
          const followsHoliday = prevIso && holidayOff.has(prevIso);
          let flagged = false;
          let context = null;

          if (followsHoliday){
            const ratio = (a,b)=> (b && b > 0) ? (a / b) : null;
            const ratioParcels = ratio(parcels, baselineParcels);
            const ratioLetters = ratio(letters, baselineLetters);
            const ratioRoute   = ratio(routeMinutes, baselineRoute);
            const overParcels = ratioParcels != null && ratioParcels >= 1.25;
            const overLetters = ratioLetters != null && ratioLetters >= 1.25;
            const overRoute   = ratioRoute != null && ratioRoute >= 1.15;
            flagged = overParcels || overLetters || overRoute;

            if (flagged){
              context = {
                baselineParcels,
                baselineLetters,
                baselineRouteMinutes: baselineRoute,
                parcels,
                letters,
                routeMinutes,
                ratioParcels,
                ratioLetters,
                ratioRoute,
                prevHoliday: prevIso,
                sampleSize: hist.count
              };
            }
          }

          if (flagged){
            if (!Array.isArray(r._tags)) r._tags = [];
            if (!r._tags.includes('post_holiday')) r._tags.push('post_holiday');
            if (!r._tags.includes('holiday_catchup')) r._tags.push('holiday_catchup');
            r._holidayCatchup = context;
            r._weightHints = Object.assign({}, r._weightHints, { holidayCatchup: { recommended: 0.65 }});
            const base = String(r.weather_json || '').trim();
            if (!/Reason:\s*Post-Holiday/i.test(base)){
              r.weather_json = base ? `${base} · Reason: Post-Holiday` : 'Reason: Post-Holiday';
            }
          }

          if (parcels > 0 || letters > 0 || routeMinutes > 0){
            hist.count += 1;
            hist.parcels += parcels;
            hist.letters += letters;
            hist.routeMinutes += routeMinutes;
          }
        }catch(_){ /* ignore per-row errors */ }
      });
    }catch(_){ /* ignore */ }
    return rows;
  }

  function hasTag(row, tag){
    return !!(row && Array.isArray(row._tags) && row._tags.includes(tag));
  }

  function summarizeHolidayCatchups(rows){
    const stats = { count:0, addedMinutes:0, avgRouteRatio:null };
    const ratios = [];
    (rows||[]).forEach(row => {
      if (!hasTag(row, 'holiday_catchup')) return;
      stats.count++;
      const ctx = row?._holidayCatchup || {};
      if (ctx.routeMinutes!=null && ctx.baselineRouteMinutes!=null){
        const delta = Math.max(0, ctx.routeMinutes - ctx.baselineRouteMinutes);
        stats.addedMinutes += delta;
      }
      if (ctx.ratioRoute!=null && isFinite(ctx.ratioRoute)) ratios.push(ctx.ratioRoute);
    });
    if (ratios.length){
      const total = ratios.reduce((sum,val)=> sum + val, 0);
      stats.avgRouteRatio = total / ratios.length;
    }
    return stats;
  }

  function loadDismissedResiduals(){
    try{
      const raw = localStorage.getItem(RESIDUAL_DISMISS_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    }catch(_){ return []; }
  }

  function saveDismissedResiduals(list){
    try{ localStorage.setItem(RESIDUAL_DISMISS_KEY, JSON.stringify(list||[])); }catch(_){ }
  }

  function buildDismissedMap(list){
    const map = new Map();
    (list||[]).forEach(item => {
      if (item && item.iso) map.set(item.iso, item);
    });
    return map;
  }

  function isHolidayDownweightEnabled(){
    try{ return localStorage.getItem(RESIDUAL_WEIGHT_PREF_KEY) === '1'; }catch(_){ return false; }
  }

  function setHolidayDownweightEnabled(on){
    try{ localStorage.setItem(RESIDUAL_WEIGHT_PREF_KEY, on ? '1' : '0'); }catch(_){ }
  }

  function getResidualWeighting(){
    const enabled = isHolidayDownweightEnabled();
    if (!enabled) return { enabled:false, fn:null };
    const fn = (row)=>{
      if (!row) return 1;
      if (!hasTag(row, 'holiday_catchup')) return 1;
      const hint = row._weightHints?.holidayCatchup?.recommended;
      if (Number.isFinite(hint) && hint > 0 && hint <= 1) return hint;
      return 0.65;
    };
    return { enabled:true, fn };
  }

  // NEW: Moon phase emoji helper
  // Improved Moon phase calc (better epoch)
function moonPhaseEmoji(dateStr) {
  const d = DateTime.fromISO(dateStr, { zone: ZONE });
  const lp = 2551442.8; // synodic month (sec)
  // Reference new moon: Jan 6, 2000 at 18:14 UTC
  const newMoon = DateTime.fromISO("2000-01-06T18:14:00Z").toSeconds();
  const phase = ((d.toSeconds() - newMoon) % lp + lp) % lp / lp;

  if (phase < 0.03 || phase > 0.97) return "🌑";   // New
  if (phase < 0.25) return "🌒";                  // Waxing crescent
  if (phase < 0.27) return "🌓";                  // First quarter
  if (phase < 0.48) return "🌔";                  // Waxing gibbous
  if (phase < 0.52) return "🌕";                  // Full
  if (phase < 0.75) return "🌖";                  // Waning gibbous
  if (phase < 0.77) return "🌗";                  // Last quarter
  return "🌘";                                    // Waning crescent
}

  function diffHours(d, t1, t2){
    if(!t1||!t2) return null;
    const a = DateTime.fromISO(`${d}T${t1}`, { zone: ZONE });
    const b = DateTime.fromISO(`${d}T${t2}`, { zone: ZONE });
    let h = (b.toMillis()-a.toMillis())/3.6e6; if(h<0) h+=24; return Math.round(h*100)/100;
  }
  function routeEndTime(){ return ($('returnTime').value || $('end').value || ''); }

  // Supabase
  const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON, { auth:{ persistSession:true }});

  // === Supabase v2 auth callback (works for PKCE or token-in-hash) ===
  async function handleAuthCallback(sb) {
    try {
      const url = new URL(window.location.href);
      const hasHashToken =
        url.hash.includes('access_token=') || url.hash.includes('refresh_token=');
      const code = url.searchParams.get('code');

      let out = null;

      if (hasHashToken) {
        // Implicit/OIDC-style callback: tokens in location.hash
        // v2: exchangeCodeForSession accepts the full hash string
        const { data, error } = await sb.auth.exchangeCodeForSession(url.hash);
        if (error) throw error;
        out = data;
      } else if (code) {
        // PKCE callback: ?code=... in query
        // v2: exchange using the code (verifier is handled internally for hosted sb.auth.signInWithOAuth)
        const { data, error } = await sb.auth.exchangeCodeForSession(code);
        if (error) throw error;
        out = data;
      } else {
        // No callback params; just ensure we have a session (or anonymous)
        const { data, error } = await sb.auth.getSession();
        if (error) console.warn('[Auth] getSession warning:', error.message);
        out = data;
      }

      // Clean up the URL so refreshes don’t re-run the callback
      if (hasHashToken || code) {
        window.history.replaceState({}, document.title, url.origin + url.pathname);
      }

      console.log('[Auth] session ready', out?.session ? '(signed in)' : '(no session)');
      return out?.session || null;
    } catch (err) {
      console.warn('Auth callback error –', err);
      return null;
    }
  }

  const authReadyPromise = handleAuthCallback(sb);

  // === Handle auth callbacks (incl. password recovery links) ===
  (async () => {
    const isRecoveryLink = /type=recovery/i.test(window.location.hash);
    if (!isRecoveryLink) return;
    const session = await authReadyPromise;
    if (!session) return;
    try {
      const p1 = prompt('Enter a new password (6+ characters)');
      if (p1 && p1.length >= 6) {
        const { error: uerr } = await sb.auth.updateUser({ password: p1 });
        if (uerr) alert('Update failed: ' + uerr.message);
        else alert('Password updated. You can now sign in normally.');
      } else {
        alert('Password must be at least 6 characters.');
      }
    } catch (e) {
      console.warn('Auth callback error', e);
    }
  })();

  // Connectivity + session bootstrap
  (async ()=>{ try{ await fetch(SUPABASE_URL,{mode:'no-cors'}); dConn.textContent='Connected'; }catch{ dConn.textContent='Error'; }})();
  (async function ensureSession(){
    const { data:{ session } } = await sb.auth.getSession();
    if(!session){ await sb.auth.signInAnonymously().catch(()=>{}); } // you can remove this later if you like
    const { data:{ user } } = await sb.auth.getUser();
    dAuth.textContent = user? 'Session' : 'No session';
  })();

  // Magic link
  const linkBtn=$('linkBtn'), linkDlg=$('linkDlg'), sendLink=$('sendLink'), email=$('email');
  linkBtn.addEventListener('click', ()=> linkDlg.showModal());
  sendLink.addEventListener('click', async (e)=>{
    e.preventDefault();
    const redirectTo = location.origin + location.pathname;
    const { error } = await sb.auth.signInWithOtp({ email: email.value, options:{ emailRedirectTo: redirectTo } });
    if (error) alert(error.message); else { alert('Check your email for the magic link.'); linkDlg.close(); }
  });
  $('signOut').addEventListener('click', ()=> sb.auth.signOut().then(()=>location.reload()));

  // === Email + Password auth ===
  const signInBtn = $('signInBtn');
  const pwDlg     = $('pwDlg');
  const loginEmail= $('loginEmail');
  const loginPass = $('loginPass');
  const doLogin   = $('doLogin');
  const doSignup  = $('doSignup');
  const authMsg   = $('authMsg');

  signInBtn?.addEventListener('click', ()=> {
    authMsg.textContent = '';
    loginEmail.value = loginEmail.value || '';
    loginPass.value = '';
    pwDlg.showModal();
  });

  doLogin?.addEventListener('click', async (e)=>{
    e.preventDefault();
    authMsg.textContent = 'Signing in…';
    const { error } = await sb.auth.signInWithPassword({
      email: (loginEmail.value||'').trim(),
      password: loginPass.value||''
    });
    if (error) {
      if (/Email not confirmed/i.test(error.message)) authMsg.textContent = 'Email not confirmed. Use reset link or check your inbox.';
      else if (/Invalid login credentials/i.test(error.message)) authMsg.textContent = 'Invalid email or password. Try Reset or Create Account.';
      else authMsg.textContent = 'Error: ' + error.message;
      return;
    }
    authMsg.textContent = 'Signed in!';
    pwDlg.close();
    const rows = await fetchEntries();
    allRows = rows;
    rebuildAll();
  });

  doSignup?.addEventListener('click', async ()=>{
    authMsg.textContent = 'Creating account…';
    const { error } = await sb.auth.signUp({
      email: (loginEmail.value||'').trim(),
      password: loginPass.value||''
    });
    authMsg.textContent = error
      ? ('Error: ' + error.message)
      : 'Account created. If email confirmation is on, check your inbox, then Sign In.';
  });

  // === Set password for the CURRENT logged-in user ===
  const setPwBtn = $('setPwBtn');
  const setPwDlg = $('setPwDlg');
  const newPass  = $('newPass');
  const newPass2 = $('newPass2');
  const setPwMsg = $('setPwMsg');
  const doSetPw  = $('doSetPw');

  setPwBtn?.addEventListener('click', ()=> {
    setPwMsg.textContent = '';
    newPass.value = '';
    newPass2.value = '';
    setPwDlg.showModal();
  });

  doSetPw?.addEventListener('click', async (e)=>{
    e.preventDefault();
    const p1 = newPass.value || '';
    const p2 = newPass2.value || '';
    if (p1.length < 6) { setPwMsg.textContent = 'Password must be at least 6 characters.'; return; }
    if (p1 !== p2)     { setPwMsg.textContent = 'Passwords do not match.'; return; }
    setPwMsg.textContent = 'Updating…';
    const { error } = await sb.auth.updateUser({ password: p1 });
    if (error) { setPwMsg.textContent = 'Error: ' + error.message; return; }
    setPwMsg.textContent = 'Password set! You can now sign in anywhere.';
    setTimeout(()=> setPwDlg.close(), 600);
  });

  // === Settings dialog (Feature Flags) ===
  const settingsDlg = document.getElementById('settingsDlg');
  const btnSettings = document.getElementById('btnSettings');
  const modelScopeSelect = document.getElementById('modelScope');
  const flagWeekdayTicks = document.getElementById('flagWeekdayTicks');
  const flagProgressivePills = document.getElementById('flagProgressivePills');
  const flagMonthlyGlance = document.getElementById('flagMonthlyGlance');
  const flagHolidayAdjust = document.getElementById('flagHolidayAdjust');
  const flagTrendPills = document.getElementById('flagTrendPills');
  const flagSameRangeTotals = document.getElementById('flagSameRangeTotals');
  const flagHeadlineDigest = document.getElementById('flagHeadlineDigest');
  const flagMixViz = document.getElementById('flagMixViz');
  const flagBaselineCompare = document.getElementById('flagBaselineCompare');
  const flagCollapsedUi = document.getElementById('flagCollapsedUi');
  const flagQuickEntry = document.getElementById('flagQuickEntry');
  const flagSmartSummary = document.getElementById('flagSmartSummary');
  const flagDayCompare = document.getElementById('flagDayCompare');
  const flagUspsEval = document.getElementById('flagUspsEval');
  const settingsEmaRate = document.getElementById('settingsEmaRate');
  // USPS Eval inputs
  const evalRouteId = document.getElementById('evalRouteId');
  const evalCode    = document.getElementById('evalCode');
  const evalBoxesIn = document.getElementById('evalBoxesIn');
  const evalStopsIn = document.getElementById('evalStopsIn');
  const evalHoursIn = document.getElementById('evalHoursIn');
  const evalOfficeHoursIn = document.getElementById('evalOfficeHoursIn');
  const evalSalaryIn = document.getElementById('evalSalaryIn');
  // Vacation mode inputs
  const vacFrom    = document.getElementById('vacFrom');
  const vacTo      = document.getElementById('vacTo');
  const vacAdd     = document.getElementById('vacAdd');
  const vacRangesEl= document.getElementById('vacRanges');
  const saveSettings = document.getElementById('saveSettings');

  btnSettings?.addEventListener('click', ()=>{
    // populate from FLAGS
    flagWeekdayTicks.checked = !!FLAGS.weekdayTicks;
    flagProgressivePills.checked = !!FLAGS.progressivePills;
    if (modelScopeSelect) modelScopeSelect.value = getModelScope();
    if (flagMonthlyGlance) flagMonthlyGlance.checked = !!FLAGS.monthlyGlance;
    if (flagHolidayAdjust) flagHolidayAdjust.checked = !!FLAGS.holidayAdjustments;
    if (flagTrendPills) flagTrendPills.checked = !!FLAGS.trendPills;
    if (flagSameRangeTotals) flagSameRangeTotals.checked = !!FLAGS.sameRangeTotals;
    if (flagHeadlineDigest) flagHeadlineDigest.checked = !!FLAGS.headlineDigest;
    if (flagMixViz) flagMixViz.checked = !!FLAGS.mixViz;
    if (flagBaselineCompare) flagBaselineCompare.checked = !!FLAGS.baselineCompare;
    if (flagCollapsedUi) flagCollapsedUi.checked = !!FLAGS.collapsedUi;
    if (flagQuickEntry) flagQuickEntry.checked = !!FLAGS.quickEntry;
    if (flagSmartSummary) flagSmartSummary.checked = !!FLAGS.smartSummary;
    if (flagDayCompare) flagDayCompare.checked = !!FLAGS.dayCompare;
    if (flagUspsEval) flagUspsEval.checked = !!FLAGS.uspsEval;
    // populate USPS eval fields
    try{
      const cfg = USPS_EVAL || loadEval();
      if (evalRouteId) evalRouteId.value = cfg.routeId || '';
      if (evalCode)    evalCode.value    = cfg.evalCode || '';
      if (evalBoxesIn) evalBoxesIn.value = (cfg.boxes!=null? cfg.boxes : '');
      if (evalStopsIn) evalStopsIn.value = (cfg.stops!=null? cfg.stops : '');
      if (evalHoursIn) evalHoursIn.value = (cfg.hoursPerDay!=null? cfg.hoursPerDay : '');
      if (evalOfficeHoursIn) evalOfficeHoursIn.value = (cfg.officeHoursPerDay!=null? cfg.officeHoursPerDay : '');
      if (evalSalaryIn) evalSalaryIn.value = (cfg.annualSalary!=null? cfg.annualSalary : '');
    }catch(_){ }
    // populate Vacation Mode
    try{
      const v = VACATION || loadVacation();
      const last = (v.ranges||[])[(v.ranges||[]).length-1];
      if (vacFrom) vacFrom.value = last?.from || '';
      if (vacTo)   vacTo.value   = last?.to   || '';
    }catch(_){ }
    try{
      if (settingsEmaRate){
        const stored = localStorage.getItem(SECOND_TRIP_EMA_KEY);
        settingsEmaRate.value = stored != null ? stored : (secondTripEmaInput?.value || '');
      }
    }catch(_){ }
    renderVacationRanges();
    settingsDlg.showModal();
  });

  saveSettings?.addEventListener('click', (e)=>{
    e.preventDefault();
    if (modelScopeSelect) setModelScope(modelScopeSelect.value);
    updateModelScopeBadge();
    FLAGS.weekdayTicks = !!flagWeekdayTicks.checked;
    FLAGS.progressivePills = !!flagProgressivePills.checked;
    if (flagMonthlyGlance) FLAGS.monthlyGlance = !!flagMonthlyGlance.checked;
    if (flagHolidayAdjust) FLAGS.holidayAdjustments = !!flagHolidayAdjust.checked;
    if (flagTrendPills) FLAGS.trendPills = !!flagTrendPills.checked;
    if (flagSameRangeTotals) FLAGS.sameRangeTotals = !!flagSameRangeTotals.checked;
    if (flagHeadlineDigest) FLAGS.headlineDigest = !!flagHeadlineDigest.checked;
    if (flagMixViz) FLAGS.mixViz = !!flagMixViz.checked;
    if (flagBaselineCompare) FLAGS.baselineCompare = !!flagBaselineCompare.checked;
    if (flagCollapsedUi) FLAGS.collapsedUi = !!flagCollapsedUi.checked;
    if (flagQuickEntry) FLAGS.quickEntry = !!flagQuickEntry.checked;
    if (flagSmartSummary) FLAGS.smartSummary = !!flagSmartSummary.checked;
    if (flagDayCompare) FLAGS.dayCompare = !!flagDayCompare.checked;
    if (flagUspsEval) FLAGS.uspsEval = !!flagUspsEval.checked;
    // read USPS eval fields
    try{
      USPS_EVAL = {
        routeId: (evalRouteId?.value||'').trim() || 'R1',
        evalCode: (evalCode?.value||'').trim() || '44K',
        boxes:    evalBoxesIn?.value!=='' ? +evalBoxesIn.value : null,
        stops:    evalStopsIn?.value!=='' ? +evalStopsIn.value : null,
        hoursPerDay: evalHoursIn?.value!=='' ? +evalHoursIn.value : null,
        officeHoursPerDay: evalOfficeHoursIn?.value!=='' ? +evalOfficeHoursIn.value : null,
        annualSalary: evalSalaryIn?.value!=='' ? +evalSalaryIn.value : null
      };
      saveEval(USPS_EVAL);
    }catch(_){ }
    // read Vacation Mode
    try{
      const f = vacFrom?.value;
      const t = vacTo?.value;
      if (f && t) addVacationRange(f, t);
      if (vacFrom) vacFrom.value = '';
      if (vacTo)   vacTo.value   = '';
    }catch(_){ }
    try{
      if (settingsEmaRate){
        const val = settingsEmaRate.value;
        if (val !== ''){
          const parsed = parseFloat(val);
          if (isFinite(parsed) && parsed >= 0){
            localStorage.setItem(SECOND_TRIP_EMA_KEY, String(parsed));
            if (secondTripEmaInput){ secondTripEmaInput.value = parsed; }
            try{ updateSecondTripSummary(); }catch(_){ }
          }
        }
        updateSecondTripSummary();
      }
    }catch(_){ }
    saveFlags(FLAGS);
    settingsDlg.close();
    renderVacationRanges();
    rebuildAll();
    renderUspsEvalTag();

    applyTrendPillsVisibility();
    applyCollapsedUi();
    applyRecentEntriesAutoCollapse();
  });

  vacAdd?.addEventListener('click', ()=>{
    try{
      const f = vacFrom?.value;
      const t = vacTo?.value;
      if (f && t){
        addVacationRange(f, t);
        if (vacFrom) vacFrom.value = '';
        if (vacTo)   vacTo.value   = '';
        renderVacationRanges();
        rebuildAll();
      }
    }catch(_){ }
  });

  vacRangesEl?.addEventListener('click', (event)=>{
    const target = event.target;
    if (!target || !target.matches('button.vac-remove[data-index]')) return;
    const idx = parseInt(target.getAttribute('data-index') || '', 10);
    if (!Number.isNaN(idx)){
      removeVacationRange(idx);
      renderVacationRanges();
      rebuildAll();
    }
  });

  // Force Refresh: update SW, clear caches, reload
  document.getElementById('forceRefreshBtn')?.addEventListener('click', async (e)=>{
    e.preventDefault();
    try{
      try{ const keys = await caches.keys(); await Promise.all(keys.map(k => caches.delete(k))); }catch(_){ }
      if ('serviceWorker' in navigator){
        const reg = await navigator.serviceWorker.getRegistration();
        try{ await reg?.update(); }catch(_){ }
        try{ reg?.waiting?.postMessage({ type:'SKIP_WAITING' }); }catch(_){ }
      }
    } finally {
      setTimeout(()=> location.reload(), 200);
    }
  });

  function applyTrendPillsVisibility(){
    const ids = ['tileAdvHours','tileAdvParcels','tileAdvLetters'];
    const show = !!(FLAGS && FLAGS.trendPills);
    ids.forEach(id=>{ const el = document.getElementById(id); if (el) el.style.display = show ? '' : 'none'; });
    const row = document.getElementById('trendPillsRow');
    if (row) row.style.display = show ? 'grid' : 'none';
  }

  // Always collapse Recent Entries by default; header click toggles open/close (independent of Collapsed UI flag)
  function applyRecentEntriesAutoCollapse(){
    try{
      const sec = document.getElementById('recentEntriesCard'); if (!sec) return;
      const headerEl = sec.firstElementChild; if (!headerEl) return;
      const KEY = 'routeStats.collapse.recentEntriesCard';
      const collapseBody = sec.querySelector(':scope > .__collapseBody');
      const collapsedUiOn = !!(FLAGS && FLAGS.collapsedUi);
      if (collapseBody || collapsedUiOn){
        // Defer to Collapsed UI system: ensure default collapsed and let its handler manage toggling
        if (localStorage.getItem(KEY) == null){ try{ localStorage.setItem(KEY, '1'); }catch(_){ } }
        try{ (window.__collapse_set||(()=>{}))('recentEntriesCard', true); }catch(_){ }
        return;
      }
      // Lightweight independent collapse for Recent Entries
      let body = sec.querySelector(':scope > .__rcBody');
      if (!body){
        body = document.createElement('div');
        body.className = '__rcBody';
        const toMove=[]; for(let i=1;i<sec.children.length;i++){ toMove.push(sec.children[i]); }
        toMove.forEach(ch=> body.appendChild(ch));
        sec.appendChild(body);
      }
      function setCollapsed(c){ body.style.display = c ? 'none' : ''; try{ localStorage.setItem(KEY, c?'1':'0'); }catch(_){ } }
      const saved = localStorage.getItem(KEY);
      const initial = (saved==null) ? true : (saved==='1');
      setCollapsed(initial);
      const toggle = ()=> setCollapsed(body.style.display!=='none'? true : false);
      headerEl.style.cursor='pointer';
      headerEl.addEventListener('click', (e)=>{ if (e.target.closest('button,a,input,select,textarea')) return; toggle(); });
      headerEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); toggle(); } });
    }catch(_){ /* ignore */ }
  }

  sb.auth.onAuthStateChange((_evt, session) => {
    const authed = !!session;
    const signOutBtn = $('signOut');
    if (signOutBtn) signOutBtn.style.display = authed ? 'inline-block' : 'none';
    dAuth.textContent = authed ? 'Session' : 'No session';
  });

  // ====== APP LOGIC (unchanged beyond tiny UX tweaks) ======

  function dowIndex(dateStr){ return DateTime.fromFormat(dateStr,'yyyy-MM-dd',{zone:ZONE}).weekday % 7; }

  function routeEndTime(){ return ($('returnTime').value || $('end').value || ''); }

  const date=$('date'), route=$('route'), start=$('start'), end=$('end'), departTime=$('departTime'), returnTime=$('returnTime');
const parcels=$('parcels'), letters=$('letters'), miles=$('miles'), mood=$('mood'), notes=$('notes');
const secondTripMilesInput=$('secondTripMiles'), secondTripTimeInput=$('secondTripTime'), secondTripEmaInput=$('secondTripEma');
const secondTripPaidEl=$('secondTripPaid'), secondTripActualEl=$('secondTripActual'), secondTripReimburseEl=$('secondTripReimburse'), secondTripEmaRateEl=$('secondTripEmaRate');
const SECOND_TRIP_EMA_KEY = 'routeStats.secondTrip.ema';
const RESIDUAL_WEIGHT_PREF_KEY = 'routeStats.residual.downweightHoliday';
const RESIDUAL_DISMISS_KEY = 'routeStats.diagnostics.dismissed';

function readStoredEma(){
  try{
    const saved = parseFloat(localStorage.getItem(SECOND_TRIP_EMA_KEY));
    if (isFinite(saved) && saved >= 0) return saved;
  }catch(_){ }
  return 0.98;
}

try{
  if (secondTripEmaInput){
    secondTripEmaInput.value = readStoredEma();
  }
}catch(_){ }
setSecondTripInputs(null);
  const weather=$('weather'), temp=$('temp'), boxholders=$('boxholders'), holiday=$('holiday');
  const offDay=$('offDay');
  const officeH=$('officeH'), routeH=$('routeH'), totalH=$('totalH');
  const expEnd=$('expEnd'), expMeta=$('expMeta');
  const badgeVolume=$('badgeVolume'), badgeRouteEff=$('badgeRouteEff'), badgeOverall=$('badgeOverall');
  const dConnEl=$('dConn'), dAuthEl=$('dAuth'), dWriteEl=$('dWrite');

  badgeVolume.title   = 'Volume = parcels + w×letters (learned from data, rank vs recent, 0–10)';
  badgeRouteEff.title = 'Route Efficiency = today’s street hours vs typical for this weekday (0–10)';
  badgeOverall.title  = 'Overall = total hours vs expected (weekday avg)';

  date.value = todayStr();
  route.value = 'R1';

  function computeBreakdown(){
    const trip = getSecondTripInputs();
    const extraHours = trip.actualMinutes ? (trip.actualMinutes / 60) : 0;
    const extraPaidMinutes = trip.miles ? (trip.miles * 2) : 0;
    if (offDay.checked){
      officeH.textContent='0.00';
      routeH.textContent='0.00';
      totalH.textContent='0.00';
      return 0;
    }
    const d=date.value; const s=start.value||'08:00';
    const off=diffHours(d, s, departTime.value);
    let rte  = diffHours(d, departTime.value, routeEndTime());
    if (rte==null && routeEndTime()){
      const span = diffHours(d, s, routeEndTime());
      if (span!=null && off!=null) rte = Math.max(0, +(span - off).toFixed(2));
    }
    const officeDisplay = (off!=null? off : 0) + extraHours;
    const tot = Math.max(0, (off??0) + (rte??0) + extraHours);
    officeH.textContent = (off!=null || extraHours) ? officeDisplay.toFixed(2) : '—';
    routeH.textContent  = rte!=null? rte.toFixed(2) : '—';
    totalH.textContent  = (off!=null||rte!=null||extraHours) ? tot.toFixed(2) : '—';
    const diag=$('diag');
    if (diag){
      const extraTxt = extraHours ? ` · <b>Extra:</b> ${trip.actualMinutes.toFixed(0)}m (${extraPaidMinutes.toFixed(0)}m paid)` : '';
      diag.innerHTML = `ROUTE STATS · Supabase: <b id="dConn">${dConn.textContent}</b> · Auth: <b id="dAuth">${dAuth.textContent}</b> · Write: <b id="dWrite">${dWrite.textContent}</b> · <b>Off:</b> ${off ?? '—'}h · <b>Route:</b> ${rte ?? '—'}h · <b>Total:</b> ${tot.toFixed(2)}h${extraTxt}`;
    }
    return tot;
  }

  // Boxholder adjustment helpers (does not change stored times; used for efficiency metrics only)
  function parseBoxholdersValue(v){
    if (v == null || v === '') return 0;
    const raw = String(v).trim().toLowerCase();
    if (!raw) return 0;
    if (/none/.test(raw)) return 0;
    if (/light/.test(raw)) return 1;
    if (/medium/.test(raw)) return 2;
    if (/heavy/.test(raw)) return 3;
    const normalized = raw.replace(/×/g,'x').replace(/\s+/g,'');
    if (/^(x?1|1x)$/.test(normalized)) return 1;
    if (/^(x?2|2x)$/.test(normalized)) return 2;
    if (/^(x?3|3x)$/.test(normalized)) return 3;
    const asNum = Number(raw);
    if (Number.isFinite(asNum) && asNum > 0){
      const rounded = Math.round(asNum);
      if (rounded >= 1 && rounded <= 3) return rounded;
    }
    return 0;
  }
  function boxholderAdjMinutes(valOrRow){
    const v = (valOrRow && typeof valOrRow==='object') ? valOrRow.boxholders : valOrRow;
    const n = parseBoxholdersValue(v);
    // Defaults: x1=+30min, x2=+45min (second adds +15), x3=+60min
    return n===1?30 : n===2?45 : n>=3?60 : 0;
  }
  // Consistent: route_minutes are stored in HOURS; adjust by subtracting boxholder minutes converted to hours
  function routeAdjustedHours(row){
    const baseH = (+row.route_minutes||0);
    const adjH  = boxholderAdjMinutes(row) / 60;
    return Math.max(0, +(baseH - adjH).toFixed(2));
  }

  function formatBoxholderLabel(val){
    if (val == null || val === '') return '—';
    const parsed = parseBoxholdersValue(val);
    if (parsed > 0) return `${parsed}x`;
    const raw = String(val).trim().toLowerCase();
    if (/light/.test(raw)) return '1x';
    if (/medium/.test(raw)) return '2x';
    if (/heavy/.test(raw)) return '3x';
    return raw ? raw : '—';
  }

  function inferBoxholderLabel(row){
    if (!row) return '—';
    const direct = formatBoxholderLabel(row.boxholders);
    if (direct !== '—') return direct;
    const weatherStr = row.weather_json ? String(row.weather_json) : '';
    if (weatherStr){
      const weatherMatch = weatherStr.match(/Box:\s*([^·]+)/i);
      if (weatherMatch){
        const normalizedWeather = formatBoxholderLabel(weatherMatch[1].trim());
        if (normalizedWeather !== '—') return normalizedWeather;
      }
    }
    const textSources = [row.reason, row.notes, weatherStr]
      .filter(Boolean)
      .map(v=> String(v).toLowerCase());
    if (!textSources.length) return '—';
    const combined = textSources.join(' ');
    if (!/box/.test(combined)) return '—';
    const match = combined.match(/box(?:holder)?[^a-z0-9]*(light|medium|heavy|x\s*\d|\d\s*x|\d+x)/i);
    if (!match) return '—';
    const token = match[1] ? match[1] : match[0];
    return formatBoxholderLabel(token.replace(/\s+/g,''));
  }

  const WEEKDAY_NAMES = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

  function roundVal(val, decimals=2){
    const n = Number(val);
    if (!Number.isFinite(n)) return null;
    const factor = Math.pow(10, decimals);
    return Math.round(n * factor) / factor;
  }

  function safeNumber(val){
    const n = Number(val);
    return Number.isFinite(n) ? n : 0;
  }

  // === Learned letter weight (OLS) ===
  let CURRENT_LETTER_WEIGHT = 0.33; // default; updated from data

  function __sum(arr, fn){ let s=0; for (const x of arr) s += +fn(x) || 0; return s; }
  function routeAdjustedMinutes(row){
    try{ if (typeof routeAdjustedHours === 'function'){ const h = routeAdjustedHours(row); return isFinite(h) ? h*60 : (+row.route_minutes||0); } }catch(_){ }
    return Math.max(0, (+row.route_minutes||0));
  }
  function computeLetterWeight(sampleRows){
    const rows = (sampleRows||[]).filter(r=> r && r.status !== 'off');
    const n = rows.length; if (!n) return null;
    const mp = __sum(rows, r=> +r.parcels||0) / n;
    const ml = __sum(rows, r=> +r.letters||0) / n;
    const my = __sum(rows, r=> routeAdjustedMinutes(r)) / n;
    let Cpp=0, Cll=0, Cpl=0, Cpy=0, Cly=0;
    for (const r of rows){
      const p=(+r.parcels||0)-mp, l=(+r.letters||0)-ml, y=routeAdjustedMinutes(r)-my;
      Cpp+=p*p; Cll+=l*l; Cpl+=p*l; Cpy+=p*y; Cly+=l*y;
    }
    const det = (Cpp*Cll - Cpl*Cpl);
    if (!isFinite(det) || Math.abs(det) < 1e-6) return null;
    const bp = ( Cpy*Cll - Cpl*Cly ) / det; // minutes per parcel
    const bl = ( Cpp*Cly - Cpl*Cpy ) / det; // minutes per letter
    if (!isFinite(bp) || Math.abs(bp) < 1e-6) return null;
    let w = bl / bp; if (!isFinite(w) || w < 0) w = 0; if (w > 1.5) w = 1.5; // guardrails
    return w;
  }
  function updateCurrentLetterWeight(allRows){
    try{
      const worked = (allRows||[]).filter(r=> r && r.status !== 'off' && ((+r.parcels||0)+(+r.letters||0) > 0))
                                   .sort((a,b)=> a.work_date < b.work_date ? -1 : 1);
      const scoped = rowsForModelScope(worked);
      const w = computeLetterWeight(scoped);
      if (w!=null) CURRENT_LETTER_WEIGHT = +(0.7*CURRENT_LETTER_WEIGHT + 0.3*w).toFixed(4);
      try{ localStorage.setItem('routeStats.letterWeight', String(CURRENT_LETTER_WEIGHT)); }catch(_){ }
    }catch(_){ /* keep default */ }
  }
  (function loadSavedLetterWeight(){
    try{ const v = parseFloat(localStorage.getItem('routeStats.letterWeight')); if (isFinite(v) && v>0) CURRENT_LETTER_WEIGHT = v; }catch(_){ }
  })();

  function combinedVolume(p, l, w){
    const W = (w==null) ? CURRENT_LETTER_WEIGHT : w; return safeNumber(p) + W * safeNumber(l);
  }

  function computeVolume(parcels, letters){
    // All volume uses the current learned weight
    return combinedVolume(parcels, letters);
  }

  function extractReasonTag(weatherStr){
    if (!weatherStr) return null;
    const match = /Reason:\s*([^·]+)/i.exec(String(weatherStr));
    return match ? match[1].trim() : null;
  }

  function colorForDelta(pct){
    if (pct == null) return { fg:'var(--muted)', bg:'transparent', bc:'var(--border)' };
    if (!FLAGS || !FLAGS.progressivePills) {
      return { fg: pct >= 0 ? 'var(--good)' : 'var(--bad)', bg:'transparent', bc:'transparent' };
    }
    const clamp = Math.max(-60, Math.min(60, pct));
    const t = Math.abs(clamp)/60;
    const green = ['#A8E6A3','#4CAF50','#087F23'];
    const red   = ['#F7A6A6','#F44336','#B71C1C'];
    const step = (t < 0.17) ? 0 : (t < 0.42 ? 1 : 2);
    const fg = clamp >= 0 ? green[step] : red[step];
    return { fg, bg:'transparent', bc:'transparent' };
  }

  function dayMetricsFromRow(row, opts){
    if (!row || row.status === 'off') return null;
    const iso = row.work_date;
    const parcelsRaw = safeNumber(row.parcels);
    const lettersRaw = safeNumber(row.letters);
    const officeRaw = safeNumber(row.office_minutes);
    const routeRaw = routeAdjustedHours(row);
    const totalRaw = row.hours!=null ? safeNumber(row.hours) : roundVal(officeRaw + routeRaw, 2);
    const milesRaw = safeNumber(row.miles);
    const volumeRaw = computeVolume(parcelsRaw, lettersRaw);
    const efficiencyMinutes = (routeRaw > 0 && volumeRaw > 0) ? roundVal((routeRaw * 60) / volumeRaw, 1) : null;

    return {
      type: opts?.type || 'day',
      source: opts?.source || 'day',
      iso,
      dow: dowIndex(iso),
      label: opts?.label || iso,
      count: 1,
      officeHours: roundVal(officeRaw, 2) ?? 0,
      routeHours: roundVal(routeRaw, 2) ?? 0,
      totalHours: roundVal(totalRaw, 2) ?? 0,
      parcels: Math.round(parcelsRaw),
      letters: Math.round(lettersRaw),
      miles: roundVal(milesRaw, 1) ?? 0,
      volume: roundVal(volumeRaw, 2) ?? 0,
      efficiencyMinutes,
      mood: row.mood || null,
      notes: row.notes || null,
      weather: row.weather_json || null,
      reason: extractReasonTag(row.weather_json),
      raw: row
    };
  }

  function aggregateDayMetrics(rows, opts){
    const valid = (rows || []).filter(r => r && r.status !== 'off');
    if (!valid.length) return null;
    const totals = valid.reduce((acc, row)=>{
      const office = safeNumber(row.office_minutes);
      const route = routeAdjustedHours(row);
      const total = row.hours!=null ? safeNumber(row.hours) : (office + route);
      const parcels = safeNumber(row.parcels);
      const letters = safeNumber(row.letters);
      const miles = safeNumber(row.miles);
      const volume = computeVolume(parcels, letters);
      acc.office += office;
      acc.route += route;
      acc.total += total;
      acc.parcels += parcels;
      acc.letters += letters;
      acc.miles += miles;
      acc.volume += volume;
      return acc;
    }, { office:0, route:0, total:0, parcels:0, letters:0, miles:0, volume:0 });
    const count = valid.length;
    const officeAvg = roundVal(totals.office / count, 2) ?? 0;
    const routeAvg = roundVal(totals.route / count, 2) ?? 0;
    const totalAvg = roundVal(totals.total / count, 2) ?? 0;
    const parcelsAvg = Math.round(totals.parcels / count);
    const lettersAvg = Math.round(totals.letters / count);
    const milesAvg = roundVal(totals.miles / count, 1) ?? 0;
    const volumeAvg = roundVal(totals.volume / count, 2) ?? 0;
    const efficiencyMinutes = (routeAvg > 0 && volumeAvg > 0) ? roundVal((routeAvg * 60) / volumeAvg, 1) : null;

    return {
      type: opts?.type || 'average',
      source: opts?.source || 'average',
      iso: null,
      dow: opts?.dow ?? null,
      label: opts?.label || 'Average',
      count,
      officeHours: officeAvg,
      routeHours: routeAvg,
      totalHours: totalAvg,
      parcels: parcelsAvg,
      letters: lettersAvg,
      miles: milesAvg,
      volume: volumeAvg,
      efficiencyMinutes,
      mood: null,
      notes: null,
      weather: null,
      reason: null,
      raw: { rows: valid, totals }
    };
  }

  function collectWorkedDays(rows, limit=365){
    const all = filterRowsForView(rows || []).filter(r=> r && r.status !== 'off' && r.work_date);
    const sorted = [...all].sort((a,b)=> a.work_date < b.work_date ? 1 : -1);
    return (limit && sorted.length > limit) ? sorted.slice(0, limit) : sorted;
  }

  function buildDayCompareContext(rows, limit=365){
    const worked = collectWorkedDays(rows, limit);
    const byDate = new Map();
    worked.forEach(r=> byDate.set(r.work_date, r));
    return { worked, byDate };
  }

  function getSubjectMetrics(context, iso){
    if (!context) return null;
    const row = (iso && context.byDate.get(iso)) || context.worked[0];
    return row ? dayMetricsFromRow(row, { source:'subject', label: row.work_date }) : null;
  }

  function getLastSameWeekdayMetrics(context, iso){
    if (!context || !iso) return null;
    const targetDow = dowIndex(iso);
    for (const row of context.worked){
      if (row.work_date === iso) continue;
      if (row.work_date < iso && dowIndex(row.work_date) === targetDow){
        const label = `Last ${WEEKDAY_NAMES[targetDow]} (${row.work_date})`;
        return dayMetricsFromRow(row, { source:'lastSameWeekday', label });
      }
    }
    return null;
  }

  function getWeekdayBaselineMetrics(context, iso){
    if (!context || !iso) return null;
    const targetDow = dowIndex(iso);
    const candidates = context.worked.filter(r=> r.work_date !== iso && dowIndex(r.work_date) === targetDow);
    if (!candidates.length) return null;
    const label = `Typical ${WEEKDAY_NAMES[targetDow]}`;
    return aggregateDayMetrics(candidates, { source:'weekdayAverage', type:'average', dow: targetDow, label });
  }

  function getCustomReferenceMetrics(context, iso){
    if (!context || !iso) return null;
    const row = context.byDate.get(iso);
    return row ? dayMetricsFromRow(row, { source:'manualReference', label: row.work_date }) : null;
  }

  function buildVolumeLeaderboard(rows){
    const panel = document.getElementById('volumeLeaderboard');
    const body = document.getElementById('volumeLeaderboardBody');
    const note = document.getElementById('volumeLeaderboardNote');
    if (!panel || !body) return;

    const worked = filterRowsForView(rows||[]).filter(r=> r && r.status!=='off' && ((+r.parcels||0)+(+r.letters||0)>0));
    if (!worked.length){
      body.innerHTML = '<tr><td colspan="5" style="text-align:center;padding:8px;color:var(--muted)">No worked days yet.</td></tr>';
      if (note) note.textContent = '—';
      return;
    }

    const weight = CURRENT_LETTER_WEIGHT;
    const volumes = worked.map(r => ({
      date: r.work_date,
      parcels: +r.parcels||0,
      letters: +r.letters||0,
      volume: combinedVolume(r.parcels, r.letters, weight)
    }));

    const asc = [...volumes].sort((a,b)=> a.volume - b.volume);
    const percentileByDate = new Map();
    asc.forEach((item, idx)=>{
      const pct = Math.round(((idx + 1) / asc.length) * 100);
      percentileByDate.set(item.date, pct);
    });

    const top = [...volumes].sort((a,b)=> b.volume - a.volume).slice(0, Math.min(10, volumes.length));
    body.innerHTML = top.map(item => {
      const dt = DateTime.fromISO(item.date, { zone: ZONE });
      const pct = percentileByDate.get(item.date);
      const pctText = (pct!=null) ? `${pct}%` : '—';
      return `<tr>
        <td>${dt.toFormat('ccc LLL dd')}</td>
        <td>${item.parcels}</td>
        <td>${item.letters}</td>
        <td>${item.volume.toFixed(1)}</td>
        <td>${pctText}</td>
      </tr>`;
    }).join('');

    if (note) note.textContent = `Combined volume = parcels + ${(weight||0).toFixed(2)}×letters`;
  }

  // === Diagnostics model & outliers ===
  function fitVolumeTimeModel(rows, opts){
    const weightFn = typeof opts?.weightFn === 'function' ? opts.weightFn : null;
    const prepared = (rows||[])
      .filter(r=> r && r.status !== 'off')
      .map(row => {
        const parcels = +row.parcels || 0;
        const letters = +row.letters || 0;
        const minutes = routeAdjustedMinutes(row);
        const raw = weightFn ? Number(weightFn(row)) : 1;
        const weight = Number.isFinite(raw) && raw > 0 ? raw : 0;
        return { row, parcels, letters, minutes, weight };
      })
      .filter(entry => entry.weight > 0);

    if (!prepared.length) return null;

    const sumW = prepared.reduce((t,e)=> t + e.weight, 0);
    if (!(sumW > 0)) return null;

    const mp = prepared.reduce((t,e)=> t + e.weight * e.parcels, 0) / sumW;
    const ml = prepared.reduce((t,e)=> t + e.weight * e.letters, 0) / sumW;
    const my = prepared.reduce((t,e)=> t + e.weight * e.minutes, 0) / sumW;

    let Cpp=0, Cll=0, Cpl=0, Cpy=0, Cly=0, SST=0, SSR=0;
    for (const e of prepared){
      const p = e.parcels - mp;
      const l = e.letters - ml;
      const y = e.minutes - my;
      const w = e.weight;
      Cpp += w * p * p;
      Cll += w * l * l;
      Cpl += w * p * l;
      Cpy += w * p * y;
      Cly += w * l * y;
      SST += w * y * y;
    }

    const det = (Cpp*Cll - Cpl*Cpl);
    if (!isFinite(det) || Math.abs(det) < 1e-6) return null;

    const bp = ( Cpy*Cll - Cpl*Cly ) / det; // minutes per parcel
    const bl = ( Cpp*Cly - Cpl*Cpy ) / det; // minutes per letter
    const a  = my - bp*mp - bl*ml;          // intercept in minutes

    const residuals = [];
    for (const e of prepared){
      const yhat = a + bp*e.parcels + bl*e.letters;
      const resid = e.minutes - yhat;
      residuals.push({
        iso: e.row.work_date,
        parcels: e.parcels,
        letters: e.letters,
        routeMin: e.minutes,
        predMin: yhat,
        residMin: resid,
        weight: e.weight,
        row: e.row
      });
      SSR += e.weight * resid * resid;
    }

    const r2 = (SST>0) ? (1 - SSR/SST) : 0;
    const downweighted = prepared.filter(e => e.weight < 0.999).length;
    return {
      a,
      bp,
      bl,
      r2,
      n: prepared.length,
      residuals,
      weighting: {
        enabled: !!weightFn,
        sumWeights: sumW,
        averageWeight: sumW / prepared.length,
        downweighted
      }
    };
  }
  function learnedLetterWeight(model){
    if (!model || !isFinite(model.bp) || Math.abs(model.bp) < 1e-6) return null;
    const w = model.bl / model.bp; return (isFinite(w) && w>=0 && w<=1.5) ? w : null;
  }
  let __residModelCache = null;

  function escapeHtml(s=''){
    return String(s)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function minutesDelta(actualMinutes, expectedMinutes){
    if (actualMinutes == null || expectedMinutes == null) return 0;
    return actualMinutes - expectedMinutes;
  }

  function formatMinutesDelta(deltaMinutes, zScore){
    const isZeroish = Math.abs(deltaMinutes) < 0.5;
    let cls = 'delta zero';
    let text = '0';
    if (!isZeroish){
      const sign = deltaMinutes > 0 ? '+' : '−';
      cls = `delta ${deltaMinutes > 0 ? 'pos' : 'neg'}`;
      text = `${sign}${Math.round(Math.abs(deltaMinutes))}m`;
    }
    if (typeof zScore === 'number' && Math.abs(zScore) >= 1.5){
      cls += ' outlier';
    }
    return `<span class="${cls}">${text}</span>`;
  }

  function buildDiagnostics(rows){
    rows = filterRowsForView(rows||[]);
    const card = document.getElementById('diagnosticsCard'); if (!card) return;
    card.style.display = 'block';
    __residModelCache = null;
    const worked = rows.filter(r=> r && r.status !== 'off' && ((+r.parcels||0)+(+r.letters||0)>0))
                       .sort((a,b)=> a.work_date < b.work_date ? -1 : 1);
    const scoped = rowsForModelScope(worked);
    const weightCfg = getResidualWeighting();
    const model = fitVolumeTimeModel(scoped, weightCfg.fn ? { weightFn: weightCfg.fn } : undefined);
    renderModelStrip(model);
    const badge = document.getElementById('diagModelBadge');
    const summaryEl = document.getElementById('diagSummary');
    const weightBtn = document.getElementById('diagHolidayWeightBtn');
    const weightNote = document.getElementById('diagWeightNote');
    const manageDismissBtn = document.getElementById('diagManageDismissed');
    const tbody = document.getElementById('diagTableBody');
    const toggleBtn = document.getElementById('toggleDiagDetails');
    const details = document.getElementById('diagDetails');

    if (weightBtn){
      if (!weightBtn.dataset.bound){
        weightBtn.addEventListener('click', ()=>{
          const next = !isHolidayDownweightEnabled();
          setHolidayDownweightEnabled(next);
          __residModelCache = null;
          rebuildAll();
        });
        weightBtn.dataset.bound = '1';
      }
      weightBtn.classList.toggle('active', !!weightCfg.enabled);
      weightBtn.textContent = weightCfg.enabled ? 'Downweight holiday catch-up · ON' : 'Downweight holiday catch-up · OFF';
    }
    if (manageDismissBtn && !manageDismissBtn.dataset.bound){
      manageDismissBtn.addEventListener('click', ()=>{
        const list = loadDismissedResiduals();
        if (!list.length){
          window.alert('No dismissed residuals yet.');
          return;
        }
        const lines = list
          .map(item => {
            const mins = item.minutes!=null ? ` · ${item.minutes}m` : '';
            const reason = item.reason ? ` · ${item.reason}` : '';
            return `${item.iso}${reason}${mins}`;
          })
          .join('\n');
        const input = window.prompt(`Dismissed residuals:\n${lines}\n\nEnter a date (yyyy-mm-dd) to reinstate, or leave blank to keep all:`, '');
        if (!input) return;
        const trimmed = input.trim();
        if (!trimmed) return;
        const updated = list.filter(item => item.iso !== trimmed);
        if (updated.length === list.length){
          window.alert(`No dismissed entry found for ${trimmed}.`);
          return;
        }
        saveDismissedResiduals(updated);
        buildDiagnostics(rows);
      });
      manageDismissBtn.dataset.bound = '1';
    }
    if (weightNote){
      if (!model){
        weightNote.textContent = weightCfg.enabled ? 'Need more data to apply weights.' : 'Weights off (full impact).';
      } else if (!weightCfg.enabled){
        weightNote.textContent = 'Weights off (full impact).';
      } else if (model.weighting){
        const dw = model.weighting.downweighted || 0;
        const avg = model.weighting.averageWeight || 1;
        weightNote.textContent = dw
          ? `${dw} day${dw===1?'':'s'} at ~${avg.toFixed(2)}× weight`
          : 'No holiday catch-up days in range.';
      } else {
        weightNote.textContent = 'Weights off (full impact).';
      }
    }
    if (!model){
      renderModelStrip(null);
      if (badge) badge.textContent = 'Insufficient data';
      if (summaryEl) summaryEl.textContent = 'Need more worked days with parcels/letters to estimate impact.';
      if (tbody) tbody.innerHTML = '';
      return;
    }
    const dismissedList = loadDismissedResiduals();
    const dismissedMap = buildDismissedMap(dismissedList);
    const w = learnedLetterWeight(model);
    if (w!=null) {
      CURRENT_LETTER_WEIGHT = +(0.7*CURRENT_LETTER_WEIGHT + 0.3*w).toFixed(4);
      try{ localStorage.setItem('routeStats.letterWeight', String(CURRENT_LETTER_WEIGHT)); }catch(_){ }
    }
    if (badge){ badge.innerHTML = `<small class="modelMetric">bp</small> <span>${model.bp.toFixed(2)}</span> · <small class="modelMetric">bl</small> <span>${model.bl.toFixed(3)}</span> · <small class="modelMetric">w</small> <span>${(w!=null?w.toFixed(2):'—')}</span>`; }
    if (summaryEl){
      const pct = Math.round(Math.max(0,Math.min(1,model.r2))*100);
      const catchupSummary = summarizeHolidayCatchups(rows);
      let summaryText = `Fit on ${model.n} days · R² ${pct}% · Predicts route minutes from parcels & letters.`;
      if (catchupSummary.count){
        const extraHours = catchupSummary.addedMinutes ? (catchupSummary.addedMinutes/60).toFixed(1) : null;
        const ratioTxt = catchupSummary.avgRouteRatio ? `${catchupSummary.avgRouteRatio.toFixed(2)}× route` : null;
        const parts = [`${catchupSummary.count} holiday catch-up day${catchupSummary.count===1?'':'s'}`];
        if (extraHours && extraHours !== '0.0') parts.push(`${extraHours}h extra`);
        if (ratioTxt) parts.push(ratioTxt);
        summaryText += ` · ${parts.join(' • ')}`;
      }
      if (weightCfg.enabled){
        const avgW = model.weighting?.averageWeight;
        const avgTxt = avgW ? ` (~${avgW.toFixed(2)}× weight)` : '';
        summaryText += ` · Holiday downweight ON${avgTxt}`;
      }
      if (dismissedList.length){
        summaryText += ` · ${dismissedList.length} dismissed`;
      }
      summaryEl.textContent = summaryText;
    }
    if (toggleBtn && details && !toggleBtn.dataset.bound){
      const labelPill = toggleBtn.querySelector('.pill[aria-hidden]');
      const setLabel = ()=>{
        if (!labelPill) return;
        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';
        labelPill.textContent = expanded ? 'Hide' : 'Details';
      };
      toggleBtn.dataset.bound = '1';
      toggleBtn.addEventListener('click', ()=>{
        const show = details.style.display==='none' || !details.style.display;
        details.style.display = show ? 'block' : 'none';
        toggleBtn.setAttribute('aria-expanded', show ? 'true' : 'false');
        setLabel();
      });
      toggleBtn.setAttribute('aria-expanded', 'false');
      setLabel();
    }
    if (tbody){
      const ZONE = 'America/Detroit';
      const residuals = model.residuals || [];
      const stats = (()=>{
        const pool = residuals.filter(r=> !dismissedMap.has(r.iso));
        if (!pool.length) return { mean:0, std:0 };
        const mean = pool.reduce((acc,r)=> acc + r.residMin, 0) / pool.length;
        if (pool.length < 2) return { mean, std:0 };
        const variance = pool.reduce((acc,r)=>{
          const diff = r.residMin - mean;
          return acc + diff*diff;
        },0) / (pool.length - 1);
        return { mean, std: Math.sqrt(Math.max(variance, 0)) };
      })();
      const visibleResiduals = residuals.filter(r=> !dismissedMap.has(r.iso));
      const top = [...visibleResiduals].sort((a,b)=> Math.abs(b.residMin) - Math.abs(a.residMin)).slice(0,10);
      tbody.innerHTML = top.map(d=>{
        const dt = luxon.DateTime.fromISO(d.iso,{zone:ZONE}).toFormat('ccc LLL dd');
        const actualMinutes = d.routeMin;
        const expectedMinutes = d.predMin;
        const expectedHours = (expectedMinutes/60).toFixed(2);
        const actualHours = (actualMinutes/60).toFixed(2);
        const deltaMinutes = minutesDelta(actualMinutes, expectedMinutes);
        const zScore = stats.std > 0 ? (d.residMin - stats.mean) / stats.std : null;
        const deltaHtml = formatMinutesDelta(deltaMinutes, zScore);
        const parcels = (+d.parcels || 0);
        const letters = (+d.letters || 0);
        const boxholders = escapeHtml(inferBoxholderLabel(d.row));
        const weatherSnippet = (d.row.weather_json || '').replace(/Reason:\s*/i,'').slice(0,80).trim();
        const weather = weatherSnippet ? escapeHtml(weatherSnippet) : '—';
        const badges = [];
        if (hasTag(d.row, 'holiday_catchup')){
          const ctx = d.row._holidayCatchup || {};
          const formatRatio = (ratio)=> ratio!=null && isFinite(ratio) ? `${ratio.toFixed(2)}×` : '—';
          const fmt = (val, decimals)=> (val!=null && isFinite(val)) ? Number(val).toFixed(decimals) : '—';
          const tipParts = [];
          if (ctx.prevHoliday) tipParts.push(`Holiday on ${ctx.prevHoliday}`);
          if (ctx.baselineParcels!=null) tipParts.push(`Parcels ${fmt(ctx.parcels,0)} vs avg ${fmt(ctx.baselineParcels,1)} (${formatRatio(ctx.ratioParcels)})`);
          if (ctx.baselineRouteMinutes!=null) tipParts.push(`Route ${fmt((ctx.routeMinutes||0)/60,2)}h vs avg ${fmt((ctx.baselineRouteMinutes||0)/60,2)}h (${formatRatio(ctx.ratioRoute)})`);
          const badgeTitle = escapeHtml(tipParts.join(' • ') || 'Follows holiday off-day with higher-than-baseline load');
          badges.push(`<span class="pill badge-holiday" title="${badgeTitle}">Holiday catch-up</span>`);
        }
        const weatherCell = badges.length ? `${weather} ${badges.join(' ')}` : weather;
        const rawNotes = (d.row.notes || '').trim();
        const noteParts = rawNotes ? rawNotes.split(/\n+/).filter(Boolean).slice(0,3) : [];
        const notesHtml = noteParts.length ? noteParts.map(n=>`<p>${escapeHtml(n)}</p>`).join('') : '<p>—</p>';
        return `<tr>
          <td class="text-left">${dt}</td>
          <td>${parcels}</td>
          <td>${letters}</td>
          <td>${expectedHours}</td>
          <td>${actualHours}</td>
          <td>${deltaHtml}</td>
          <td class="text-left">${boxholders}</td>
          <td class="text-left">${weatherCell}</td>
          <td class="notes-cell">${notesHtml}</td>
          <td><button class="ghost diag-dismiss" data-dismiss-iso="${d.iso}">Tag & dismiss</button></td>
        </tr>`;
      }).join('');
      const dismissBtns = tbody.querySelectorAll('.diag-dismiss');
      dismissBtns.forEach(btn => {
        btn.addEventListener('click', ()=>{
          const iso = btn.dataset.dismissIso;
          if (!iso) return;
          const residual = residuals.find(r => r.iso === iso);
          const deltaMinutes = residual ? Math.round(residual.residMin) : null;
          const vol = residual ? Math.round(residual.parcels) : null;
          const letterCount = residual ? Math.round(residual.letters) : null;
          const defaultReason = (() => {
            if (!residual) return '';
            if (vol != null && vol > 0 && letterCount != null && letterCount === 0) return 'parcels';
            if (letterCount != null && letterCount > vol) return 'letters';
            return '';
          })();
          const defaultMinutes = deltaMinutes != null ? String(deltaMinutes) : '';
          const hintParts = [];
          if (deltaMinutes != null) hintParts.push(`Residual: ${deltaMinutes}m`);
          if (vol != null) hintParts.push(`Parcels: ${vol}`);
          if (letterCount != null) hintParts.push(`Letters: ${letterCount}`);
          const basePrompt = hintParts.length ? `${hintParts.join(' · ')}\nReason (e.g., Road closure, Weather, Extra parcels):` : 'Reason (e.g., Road closure, Weather, Extra parcels):';
          const reasonPrompt = window.prompt(basePrompt, defaultReason);
          if (reasonPrompt === null) return; // user cancelled
          const reason = reasonPrompt.trim();
          const minutesPrompt = window.prompt('Minutes attributable to this reason (optional, numbers only):', defaultMinutes);
          let minutes = null;
          if (minutesPrompt && minutesPrompt.trim()){
            const parsed = parseFloat(minutesPrompt.trim());
            if (isFinite(parsed)) minutes = parsed;
          }
          const entry = {
            iso,
            reason: reason || 'dismissed',
            minutes,
            notedAt: new Date().toISOString()
          };
          const existing = loadDismissedResiduals().filter(item => item && item.iso !== iso);
          existing.push(entry);
          saveDismissedResiduals(existing);
          buildDiagnostics(rows);
        });
      });
    }
  }

  // === Residual badges helpers ===
  function computeResidualForRow(row, model){
    if (!model) return null;
    const y   = routeAdjustedMinutes(row);
    const p   = +row.parcels || 0;
    const l   = +row.letters || 0;
    const yhat = model.a + model.bp*p + model.bl*l;
    return y - yhat; // minutes (positive = slower than volume predicts)
  }

  function getResidualModel(rows){
    if (__residModelCache) return __residModelCache;
    const worked = (rows||[]).filter(r=> r && r.status!=='off' && ((+r.parcels||0)+(+r.letters||0)>0))
                             .sort((a,b)=> a.work_date < b.work_date ? -1 : 1);
    const scoped = rowsForModelScope(worked);
    const weightCfg = getResidualWeighting();
    __residModelCache = fitVolumeTimeModel(scoped, weightCfg.fn ? { weightFn: weightCfg.fn } : undefined);
    return __residModelCache;
  }

  function renderResidualBadge(row, model, threshold=25){
    const resid = computeResidualForRow(row, model);
    if (resid == null) return '';
    const m = Math.round(resid);
    if (Math.abs(m) < threshold) return '';
    const cls = m > 0 ? 'down' : 'up';
    const sign = m > 0 ? '+' : '';
    const title = m > 0
      ? 'Slower than volume predicts (unexplained minutes)'
      : 'Faster than volume predicts (unexplained minutes)';
    return `<span class="pill ${cls}" title="${title}">${sign}${m}m unexplained</span>`;
  }

  function renderModelStrip(model){
    const el = document.getElementById('liveModelStrip');
    if (!el) return;
    if (!model){ el.style.display = 'none'; return; }
    const bp = document.getElementById('lm-bp');
    const bl = document.getElementById('lm-bl');
    const wv = document.getElementById('lm-w');
    const r2 = document.getElementById('lm-r2');
    const w = (model.bp && isFinite(model.bp)) ? (model.bl / model.bp) : NaN;
    if (bp) bp.textContent = model.bp.toFixed(2);
    if (bl) bl.textContent = model.bl.toFixed(3);
    if (wv) wv.textContent = isFinite(w) ? w.toFixed(2) : '—';
    if (r2) r2.textContent = (Math.max(0, Math.min(1, model.r2)) * 100).toFixed(0) + '%';
    el.style.display = 'flex';
  }

  const DAY_COMPARE_STORE = {
    subject: 'routeStats.dayCompare.subject',
    mode: 'routeStats.dayCompare.mode',
    manual: 'routeStats.dayCompare.manual'
  };

  function buildDayCompare(rows){
    rows = filterRowsForView(rows||[]);
    const card = document.getElementById('dayCompareCard');
    const dailyMovers = document.getElementById('dcDailyMovers');
    if (!card){ if (dailyMovers) dailyMovers.style.display='none'; return; }
    if (!FLAGS || !FLAGS.dayCompare){
      card.style.display = 'none';
      if (dailyMovers) dailyMovers.style.display='none';
      return;
    }
    card.style.display = 'block';

    const subjectSelect   = document.getElementById('dcSubjectSelect');
    const referenceSelect = document.getElementById('dcReferenceMode');
    const manualPicker    = document.getElementById('dcManualPicker');
    const manualSelect    = document.getElementById('dcManualSelect');
    const emptyState      = document.getElementById('dcEmpty');
    const compareState    = document.getElementById('dcCompare');
    const subjectLabel    = document.getElementById('dcSubjectLabel');
    const referenceLabel  = document.getElementById('dcReferenceLabel');
    const subjectPills    = document.getElementById('dcSubjectPills');
    const referencePills  = document.getElementById('dcReferencePills');
    const subjectNotes    = document.getElementById('dcSubjectNotes');
    const referenceNotes  = document.getElementById('dcReferenceNotes');
    const highlightsRow   = document.getElementById('dcHighlights');
    const reasoningEl     = document.getElementById('dcReasoning');
    const tableBody       = document.getElementById('dcTableBody');
    const toggleBtn       = document.getElementById('dcToggleRef');
    if (!subjectSelect || !referenceSelect || !manualSelect || !emptyState || !compareState || !tableBody) return;

    const context = buildDayCompareContext(rows, 365);
    const worked = context.worked;
    if (!worked.length){
      emptyState.textContent = 'No worked days yet. Add an entry to compare.';
      emptyState.style.display = 'block';
      compareState.style.display = 'none';
      if (toggleBtn) toggleBtn.style.display = 'none';
      if (dailyMovers) dailyMovers.style.display='none';
      return;
    }

    const storedSubject = localStorage.getItem(DAY_COMPARE_STORE.subject);
    let storedMode = localStorage.getItem(DAY_COMPARE_STORE.mode) || 'last';
    const storedManualInitial = localStorage.getItem(DAY_COMPARE_STORE.manual);

    function formatOption(row){
      try{
        const dt = DateTime.fromISO(row.work_date, { zone: ZONE });
        const day = dt.toFormat('ccc');
        const date = dt.toFormat('LLL dd');
        const total = row.hours != null ? row.hours : (safeNumber(row.office_minutes) + routeAdjustedHours(row));
        const totalTxt = (total==null) ? '—' : `${roundVal(total,2)?.toFixed(2) || '—'}h`;
        const glyph = vacGlyph(row.work_date);
        return `${row.work_date}${glyph} · ${day} ${date} · ${totalTxt}`;
      }catch(_){ return row.work_date; }
    }

    function formatNumber(val, opts){
      const decimals = opts?.decimals ?? 2;
      const suffix = opts?.suffix || '';
      const n = val==null ? null : roundVal(val, decimals);
      if (n==null || !Number.isFinite(n)) return '—';
      return `${n.toFixed(decimals)}${suffix}`;
    }

    subjectSelect.innerHTML = worked.map(row => `<option value="${row.work_date}">${formatOption(row)}</option>`).join('');
    subjectSelect.value = (storedSubject && subjectSelect.querySelector(`option[value="${storedSubject}"]`)) ? storedSubject : (worked[0]?.work_date || '');

    const manualOption = referenceSelect.querySelector('option[value="manual"]');
    const manualAvailable = worked.length > 1;
    if (manualOption){
      manualOption.disabled = !manualAvailable;
      if (!manualAvailable && storedMode === 'manual') storedMode = 'last';
    }
    referenceSelect.value = storedMode;

    function subjectIso(){ return subjectSelect.value || worked[0]?.work_date; }

    function modeLabel(mode){
      return mode === 'last' ? 'Last weekday' : mode === 'baseline' ? 'Baseline avg' : mode === 'manual' ? 'Picked day' : mode;
    }

    function populateManualOptions(){
      const current = subjectIso();
      const altRows = worked.filter(r=> r.work_date !== current);
      manualSelect.innerHTML = altRows.map(row => `<option value="${row.work_date}">${formatOption(row)}</option>`).join('');
      if (!altRows.length){ manualSelect.value=''; return; }
      const latestStored = localStorage.getItem(DAY_COMPARE_STORE.manual) || storedManualInitial;
      manualSelect.value = (latestStored && manualSelect.querySelector(`option[value="${latestStored}"]`)) ? latestStored : altRows[0].work_date;
    }

    populateManualOptions();
    manualPicker.style.display = referenceSelect.value === 'manual' ? 'block' : 'none';

    function formatLabel(metric){
      if (!metric) return '—';
      if (metric.source === 'weekdayAverage'){
        const countTxt = metric.count ? `avg of ${metric.count} day${metric.count===1?'':'s'}` : 'avg';
        return `${metric.label} (${countTxt})`;
      }
      if (metric.iso){
        try{
          const dt = DateTime.fromISO(metric.iso, { zone: ZONE });
          return dt.toFormat('cccc, LLL dd');
        }catch(_){ return metric.iso; }
      }
      return metric.label || '—';
    }

    function summarizeExtras(metric){
      if (!metric) return '';
      const parts = [];
      if (metric.mood) parts.push(`Mood: ${metric.mood}`);
      if (metric.weather) parts.push(`Weather: ${metric.weather}`);
      if (metric.reason) parts.push(`Reason: ${metric.reason}`);
      if (metric.notes) parts.push(`Notes: ${metric.notes}`);
      return parts.join(' • ');
    }

    function pillHtml(label, value){
      return `<span class="pill"><small>${label}</small> <b>${value}</b></span>`;
    }

    function deltaDetails(subject, reference){
      if (!subject || !reference) return { rows: [], highlights: [], reasoning: '' };
      const metricDefs = [
        { key:'totalHours', label:'Total hours', decimals:2, suffix:'h' },
        { key:'routeHours', label:'Route hours', decimals:2, suffix:'h' },
        { key:'officeHours', label:'Office hours', decimals:2, suffix:'h' },
        { key:'parcels', label:'Parcels', decimals:0 },
        { key:'letters', label:'Letters', decimals:0 },
        { key:'volume', label:'Volume (parcels + w×letters)', decimals:2 },
        { key:'miles', label:'Miles', decimals:1, suffix:'mi' },
        { key:'efficiencyMinutes', label:'Route minutes per volume', decimals:1, suffix:'m/vol' }
      ];

      const rowsOut = [];
      const highlights = [];

      for (const def of metricDefs){
        const subjVal = subject[def.key];
        const refVal = reference[def.key];
        const delta = (subjVal != null && refVal != null) ? subjVal - refVal : null;
        const pct = (refVal != null && refVal !== 0 && delta != null) ? (delta / refVal) * 100 : null;
        const colorDelta = def.invert && pct!=null ? -pct : pct;
        const displayDelta = delta==null ? '—' : formatNumber(delta, { decimals: def.decimals ?? 2, suffix: def.suffix ? def.suffix : '' });
        const pctTxt = pct==null || !Number.isFinite(pct) ? '' : ` (${pct>=0?'+':''}${Math.round(pct)}%)`;
        const deltaTxt = delta==null ? '—' : `${displayDelta}${pctTxt}`;
        const subjTxt = subjVal==null ? '—' : formatNumber(subjVal, { decimals: def.decimals ?? 2, suffix: def.suffix ? def.suffix : '' });
        const refTxt = refVal==null ? '—' : formatNumber(refVal, { decimals: def.decimals ?? 2, suffix: def.suffix ? def.suffix : '' });
        const color = colorForDelta(colorDelta ?? 0).fg;
        rowsOut.push({ key:def.key, label:def.label, subjTxt, refTxt, deltaTxt, color, delta, score: Math.abs(pct ?? delta ?? 0) });
        if (delta != null) highlights.push({ key:def.key, label:def.label, deltaText: deltaTxt, color, score: Math.abs(pct ?? delta ?? 0) });
      }

      highlights.sort((a,b)=> Math.abs(b.score) - Math.abs(a.score));
      const reasoningBits = [];
      if (subject.reason) reasoningBits.push(`Subject reason: ${subject.reason}`);
      if (reference.reason) reasoningBits.push(`Reference reason: ${reference.reason}`);
      const reasoning = reasoningBits.join(' • ');

      return { rows: rowsOut, highlights, reasoning };
    }

    function render(){
      const subjIso = subjectIso();
      if (!subjIso){
        emptyState.textContent = 'No worked day selected.';
        emptyState.style.display = 'block';
        compareState.style.display = 'none';
        if (dailyMovers) dailyMovers.style.display='none';
        return;
      }

      const subjectMetrics = getSubjectMetrics(context, subjIso);
      const mode = referenceSelect.value;
      let referenceMetrics = null;
      if (mode === 'last') referenceMetrics = getLastSameWeekdayMetrics(context, subjIso);
      else if (mode === 'baseline') referenceMetrics = getWeekdayBaselineMetrics(context, subjIso);
      else if (mode === 'manual') referenceMetrics = getCustomReferenceMetrics(context, manualSelect.value);

      if (toggleBtn) toggleBtn.textContent = `Cycle reference (${modeLabel(mode)})`;

      emptyState.style.display = 'none';

      if (!referenceMetrics){
        compareState.style.display = 'none';
        emptyState.textContent = 'Not enough history for that comparison yet. Try a different reference.';
        emptyState.style.display = 'block';
        if (dailyMovers) dailyMovers.style.display='none';
        return;
      }

      compareState.style.display = 'block';
      if (subjectLabel){
        const subjText = formatLabel(subjectMetrics);
        subjectLabel.innerHTML = subjectMetrics?.iso ? `${subjText}${vacMark(subjectMetrics.iso)}` : subjText;
      }
      if (referenceLabel){
        const refText = formatLabel(referenceMetrics);
        referenceLabel.innerHTML = referenceMetrics?.iso ? `${refText}${vacMark(referenceMetrics.iso)}` : refText;
      }

      subjectPills.innerHTML = [
        pillHtml('Total', formatNumber(subjectMetrics.totalHours, { decimals:2, suffix:'h' })),
        pillHtml('Route', formatNumber(subjectMetrics.routeHours, { decimals:2, suffix:'h' })),
        pillHtml('Office', formatNumber(subjectMetrics.officeHours, { decimals:2, suffix:'h' })),
        pillHtml('Volume', formatNumber(subjectMetrics.volume, { decimals:2 })),
        pillHtml('Eff.', formatNumber(subjectMetrics.efficiencyMinutes, { decimals:1, suffix:'m/vol' }))
      ].join(' ');

      referencePills.innerHTML = [
        pillHtml('Total', formatNumber(referenceMetrics.totalHours, { decimals:2, suffix:'h' })),
        pillHtml('Route', formatNumber(referenceMetrics.routeHours, { decimals:2, suffix:'h' })),
        pillHtml('Office', formatNumber(referenceMetrics.officeHours, { decimals:2, suffix:'h' })),
        pillHtml('Volume', formatNumber(referenceMetrics.volume, { decimals:2 })),
        pillHtml('Eff.', formatNumber(referenceMetrics.efficiencyMinutes, { decimals:1, suffix:'m/vol' }))
      ].join(' ');

      subjectNotes.textContent = summarizeExtras(subjectMetrics) || '—';
      referenceNotes.textContent = summarizeExtras(referenceMetrics) || '—';

      const { rows: tableRows, highlights, reasoning } = deltaDetails(subjectMetrics, referenceMetrics);
      tableBody.innerHTML = tableRows.map(r=> `<tr>
        <td style="padding:6px 4px">${r.label}</td>
        <td style="padding:6px 4px;text-align:right">${r.subjTxt}</td>
        <td style="padding:6px 4px;text-align:right">${r.refTxt}</td>
        <td style="padding:6px 4px;text-align:right;color:${r.color}">${r.deltaTxt}</td>
      </tr>`).join('');

      if (dailyMovers){
        const moverKeys = ['totalHours','routeHours','officeHours'];
        dailyMovers.innerHTML = moverKeys.map(key=>{
          const row = tableRows.find(r=> r.key === key);
          const hasDelta = row && row.delta != null;
          const label = key === 'totalHours' ? 'Total' : key === 'routeHours' ? 'Route' : 'Office';
          const text = hasDelta ? row.deltaTxt : '—';
          const color = hasDelta ? row.color : 'var(--muted)';
          return `<span class="pill" style="border-color:var(--border);color:${color}"><small>${label}</small> <b>${text}</b></span>`;
        }).join(' ');
        dailyMovers.style.display = 'flex';
      }

      const candidateHighlights = highlights.length
        ? highlights
        : tableRows.map(r=> ({ key:r.key, label:r.label, deltaText:r.deltaTxt, color:r.color }));
      const highlightHtml = candidateHighlights
        .slice(0,3)
        .map(h=> `<span class="pill" style="border-color:var(--border);color:${h.color}"><small>${h.label}</small> <b>${h.deltaText}</b></span>`)
        .join(' ');
      highlightsRow.innerHTML = highlightHtml || '<span class="pill"><small>Δ</small> <b style="color:var(--muted)">Similar</b></span>';
      reasoningEl.textContent = reasoning || '';

      localStorage.setItem(DAY_COMPARE_STORE.subject, subjIso);
      localStorage.setItem(DAY_COMPARE_STORE.mode, mode);
      if (mode === 'manual' && manualSelect.value){
        localStorage.setItem(DAY_COMPARE_STORE.manual, manualSelect.value);
      }
    }

    subjectSelect.onchange = ()=>{ populateManualOptions(); render(); };
    referenceSelect.onchange = ()=>{ manualPicker.style.display = referenceSelect.value === 'manual' ? 'block' : 'none'; render(); };
    manualSelect.onchange = ()=>{ render(); };

    if (toggleBtn){
      const sequence = ['last','baseline','manual'];
      const available = manualAvailable ? sequence : sequence.slice(0,2);
      toggleBtn.style.display = available.length > 1 ? '' : 'none';
      toggleBtn.onclick = ()=>{
        const current = referenceSelect.value;
        const idx = available.indexOf(current);
        const next = available[(idx + 1) % available.length];
        referenceSelect.value = next;
        referenceSelect.dispatchEvent(new Event('change'));
      };
    }

    render();
  }

  function setNow(el){ el.value=hhmmNow(); computeBreakdown(); }
  $('btnStartNow').addEventListener('click',()=>{ if(!start.value) setNow(start); });
  $('btnStreetNow').addEventListener('click',()=> setNow(departTime));
  $('btnClockNow').addEventListener('click',()=>{ setNow(end); if(!returnTime.value){ returnTime.value = end.value; } });
  $('btnStartNow2').addEventListener('click',()=> setNow(start));
  $('btnStreetNow2').addEventListener('click',()=> setNow(departTime));
  $('btnReturnNow').addEventListener('click',()=> setNow(returnTime));
  $('btnClockNow2').addEventListener('click',()=>{ setNow(end); if(!returnTime.value){ returnTime.value = end.value; } });

  offDay.addEventListener('change', ()=>{ if(offDay.checked){ end.value=hhmmNow(); parcels.value=letters.value=miles.value=0; mood.value='🛑 off'; computeBreakdown(); }});
;[date,start,departTime,returnTime,end,parcels,letters,miles,offDay,weather,temp,boxholders].forEach(el=> el.addEventListener('input', computeBreakdown));
secondTripMilesInput?.addEventListener('input', updateSecondTripSummary);
secondTripTimeInput?.addEventListener('input', updateSecondTripSummary);
secondTripEmaInput?.addEventListener('input', updateSecondTripSummary);

  document.addEventListener('keydown', (e)=>{
    const mod = e.metaKey || e.ctrlKey; if(!mod) return; const k = e.key.toLowerCase();
    if(k==='s'){ e.preventDefault(); $('save')?.click(); }
    else if(k==='d'){ e.preventDefault(); $('btnEditLast')?.click(); }
    else if(e.key==='Backspace'){ e.preventDefault(); $('btnDeleteDay')?.click(); }
  });

function weatherString(){
    const parts=[]; if(weather?.value) parts.push(weather.value); if(temp?.value) parts.push(`${temp.value}°F`); if(boxholders?.value) parts.push(`Box: ${boxholders.value}`); if (holiday?.checked) parts.push('Holiday'); if (reasonTag?.value) parts.push(`Reason: ${reasonTag.value}`);
    const st = getSecondTripPayload();
    if (st){ parts.push(`SecondTrip:${JSON.stringify(st)}`); }
    return parts.length? parts.join(' · ') : null;
  }

  function collectPayload(userId){
    const d=date.value; const s=start.value||'08:00';
    const offRaw = diffHours(d, s, departTime.value);
    let rteRaw   = diffHours(d, departTime.value, routeEndTime());
    if (rteRaw==null && routeEndTime()){
      const span = diffHours(d, s, routeEndTime());
      if (span!=null && offRaw!=null) rteRaw = Math.max(0, +(span - offRaw).toFixed(2));
    }
    const trip = getSecondTripInputs();
    const extraHours = trip.actualMinutes ? (trip.actualMinutes / 60) : 0;
    const off = offDay.checked ? 0 : offRaw;
    const rte = offDay.checked ? 0 : rteRaw;
    const tot = offDay.checked ? 0 : ((off??0)+(rte??0)+extraHours);
    const officeForStore = offDay.checked ? 0 : (offRaw!=null ? +(offRaw + extraHours).toFixed(2) : (extraHours ? +extraHours.toFixed(2) : null));
    return {
      user_id:userId,
      work_date:d,
      route:'R1',
      start_time:   offDay.checked ? null : (s||null),
      end_time:     offDay.checked ? null : (end.value || null),
      hours:        offDay.checked ? 0 : (tot||null),
      parcels:      offDay.checked ? 0 : (+parcels.value||0),
      letters:      offDay.checked ? 0 : (+letters.value||0),
      miles:        offDay.checked ? 0 : (+miles.value||0),
      mood:         offDay.checked ? '🛑 off' : (mood.value||null),
      notes:        notes.value||null,
      status:       offDay.checked ? 'off' : 'worked',
      office_start: s||null,
      depart_time:  departTime.value||null,
      return_time:  returnTime.value||null,
      office_minutes: offDay.checked ? 0 : officeForStore,
      route_minutes:  offDay.checked ? 0 : (rteRaw!=null? +rteRaw.toFixed(2): null),
      weather_json: weatherString()
    };
  }

  function fillForm(r){
    start.value       = r.start_time || '08:00';
    end.value         = r.end_time   || '';
    departTime.value  = r.depart_time || '';
    returnTime.value  = r.return_time || '';
    parcels.value     = r.parcels || 0;
    letters.value     = r.letters || 0;
    miles.value       = r.miles   || 0;
    mood.value        = r.mood    || '';
    notes.value       = r.notes   || '';
    offDay.checked    = (r.status === 'off');

    const raw = r.weather_json || '';
    if (!raw){
      if(temp) temp.value='';
      if(boxholders) boxholders.value='';
      if(holiday) holiday.checked=false;
      weather.value='';
      const reasonTag = document.getElementById('reasonTag'); if (reasonTag) reasonTag.value = '';
      setSecondTripInputs(null);
    } else {
      const parts = String(raw).split('·').map(s=>s.trim());
      let w='', t='', b=''; let hol=false; let rsn=''; let stData=null;
      for (const p of parts){
        if (/°F$/.test(p)) t = p.replace('°F','').trim();
        else if (/^Box:/i.test(p)) b = p.split(':').slice(1).join(':').trim();
        else if (/^Reason:/i.test(p)) rsn = p.split(':').slice(1).join(':').trim();
        else if (/^SecondTrip:/i.test(p)) {
          try{ stData = JSON.parse(p.split(':').slice(1).join(':')); }catch(_){ stData=null; }
        }
        else if (/^Holiday$/i.test(p)) hol = true;
        else w = p;
      }
      weather.value = w || '';
      if (temp) temp.value = t || '';
      if (boxholders) boxholders.value = b || '';
      if (holiday) holiday.checked = !!hol;
      const reasonTag = document.getElementById('reasonTag'); if (reasonTag) reasonTag.value = rsn || '';
      setSecondTripInputs(stData);
    }
    try { computeBreakdown(); } catch(_){}
  }

  let editingKey = null; let lastDeleted = null; const btnUndoDelete = $('btnUndoDelete');
  function showUndo(show){ if(!btnUndoDelete) return; btnUndoDelete.style.display = show ? 'inline-block' : 'none'; }

const searchBox = $('searchBox'); let allRows = [];
function applySearch(rows){
    const q = (searchBox.value||'').trim().toLowerCase(); if(!q) return rows;
    return rows.filter(r=>{
      const fields=[ r.work_date, r.status, r.mood, r.weather_json, r.notes, String(r.parcels||''), String(r.letters||''), String(r.miles||'') ];
      return fields.some(v=> String(v||'').toLowerCase().includes(q));
    });
  }

function getSecondTripInputs(){
  if (!secondTripMilesInput) return { miles:0, actualMinutes:0, ema:0.98 };
  const miles = parseFloat(secondTripMilesInput.value || '');
  const actual = parseInt(secondTripTimeInput.value || '');
  const emaRaw = secondTripEmaInput ? parseFloat(secondTripEmaInput.value || '') : NaN;
  const ema = isFinite(emaRaw) && emaRaw >= 0 ? emaRaw : readStoredEma();
  if (secondTripEmaInput && (!isFinite(emaRaw) || emaRaw < 0)) {
    secondTripEmaInput.value = ema;
  }
  return {
    miles: isFinite(miles) && miles >= 0 ? miles : 0,
    actualMinutes: isFinite(actual) && actual >= 0 ? actual : 0,
    ema
  };
}

function getSecondTripPayload(){
  const { miles, actualMinutes, ema } = getSecondTripInputs();
  if (!(miles > 0 || actualMinutes > 0)) return null;
  return {
    m: +miles.toFixed(2),
    t: actualMinutes,
    e: +ema.toFixed(2)
  };
}

function updateSecondTripSummary(){
  if (!secondTripMilesInput) return;
  const { miles, actualMinutes, ema } = getSecondTripInputs();
  const paidMinutes = miles * 2;
  const gas = miles * ema;
  if (secondTripPaidEl) secondTripPaidEl.textContent = paidMinutes.toFixed(0);
  if (secondTripActualEl) secondTripActualEl.textContent = actualMinutes.toFixed(0);
  if (secondTripReimburseEl) secondTripReimburseEl.textContent = gas.toFixed(2);
  if (secondTripEmaRateEl) secondTripEmaRateEl.textContent = ema.toFixed(2);
  // Persist user EMA preference
  try{ if (ema>0) localStorage.setItem(SECOND_TRIP_EMA_KEY, String(ema)); }catch(_){ }
  try{ computeBreakdown(); }catch(_){ }
}

function setSecondTripInputs(data){
  if (!secondTripMilesInput) return;
  const obj = data || { m:'', t:'', e:readStoredEma() };
  secondTripMilesInput.value = obj.m!=null && obj.m!=='' ? obj.m : '';
  secondTripTimeInput.value  = obj.t!=null && obj.t!=='' ? obj.t : '';
  if (secondTripEmaInput){
    const emaVal = obj.e!=null && obj.e!=='' ? obj.e : readStoredEma();
    secondTripEmaInput.value = emaVal;
  }
  updateSecondTripSummary();
}

function parseSecondTripFromRow(row){
  if (!row || !row.weather_json) return null;
  const part = row.weather_json.split('·').map(s=> s.trim()).find(p => /^SecondTrip:/i.test(p));
  if (!part) return null;
  try{ return JSON.parse(part.split(':').slice(1).join(':')); }catch(_){ return null; }
}

function getHourlyRateFromEval(){
  try{
    const cfg = USPS_EVAL || loadEval();
    if (!cfg || cfg.annualSalary==null || cfg.hoursPerDay==null) return null;
    const weeklyPay = cfg.annualSalary / 52;
    const hoursPerWeek = Math.max(0, (cfg.hoursPerDay||0) * 5);
    if (!hoursPerWeek) return null;
    return weeklyPay / hoursPerWeek;
  }catch(_){ return null; }
}


  function rebuildAll(){
    const rows = allRows || [];
    const rawRows = rows;
    const normalRows = rows.filter(r => r && r.status !== 'off');

    window.__rawRows = rawRows;
    window.allRows = rows;
    window.__holidayCatchupStats = summarizeHolidayCatchups(rawRows);
    updateCurrentLetterWeight(normalRows);
    renderTable(applySearch(rawRows));
    buildCharts(rawRows);
    buildSnapshot(rawRows);
    buildMonthlyGlance(rawRows);
    buildQuickFilter(rawRows);
    buildMixViz(rawRows);
    buildHeadlineDigest(rawRows);
    buildSmartSummary(rawRows);
    buildTrendingFactors(rawRows);
    buildOfficeCompare(rawRows);
    buildDayCompare(rawRows);
    buildHeavinessToday(rawRows);
    buildWeekHeaviness(rawRows);
    buildUspsTiles(rawRows);
    buildDiagnostics(normalRows);
    buildVolumeLeaderboard(rawRows);
  }

  async function loadByDate(){
    editingKey = null; const { data:{ user } } = await sb.auth.getUser(); if(!user) return; const d=date.value; if(!d) return;
    const { data, error } = await sb.from('entries').select('*').eq('user_id', user.id).eq('work_date', d).limit(1).maybeSingle();
    if (error && error.code !== 'PGRST116') { console.error(error); return; }
    const saveBtn=$('save'); saveBtn.classList.remove('ghost');
    if (data) { editingKey = { user_id:user.id, work_date:d }; fillForm(data); saveBtn.textContent='Update'; }
    else { saveBtn.textContent='Save'; }
  }
  date.addEventListener('change', loadByDate);

  (function replaceSave(){
    const btn=$('save'); const clone=btn.cloneNode(true); btn.parentNode.replaceChild(clone,btn);
    clone.addEventListener('click', async ()=>{
      const { data:{ user } } = await sb.auth.getUser(); if (!user) { alert('No session. Try Link devices or refresh.'); return; }
      const payload = collectPayload(user.id); let error;
      try{
        // Guard against duplicates: replace all rows for this user/date with a single fresh payload
        const { data: existing, error: findErr } = await sb
          .from('entries').select('work_date', { count: 'exact', head: false })
          .eq('user_id', user.id).eq('work_date', payload.work_date);
        if (findErr) console.warn('find existing failed', findErr);
        const exists = Array.isArray(existing) && existing.length > 0;
        if (exists){
          const { error: delErr } = await sb.from('entries').delete().eq('user_id', user.id).eq('work_date', payload.work_date);
          if (delErr) { error = delErr; throw delErr; }
          const { error: insErr } = await sb.from('entries').insert(payload);
          if (insErr) { error = insErr; throw insErr; }
        } else {
          const { error: insErr } = await sb.from('entries').insert(payload);
          if (insErr) { error = insErr; throw insErr; }
        }
      }catch(e){ error = e; }
      dWrite.textContent = error ? 'Failed' : 'OK'; if (error){ alert(error.message); return; }
      clone.textContent = 'Update'; clone.disabled = true; clone.classList.add('saving','savedFlash');
      setTimeout(()=>{ clone.disabled=false; clone.classList.remove('saving'); }, 400); setTimeout(()=> clone.classList.remove('savedFlash'), 700);
      const rows = await fetchEntries();
      allRows = rows;
      rebuildAll();
      editingKey = { user_id:user.id, work_date:date.value }; clone.classList.remove('ghost');
    });
  })();

  $('btnEditLast')?.addEventListener('click', async ()=>{
    const rows = await fetchEntries(); if(!rows.length){ alert('No entries yet.'); return; }
    const latest = rows[0]; $('date').value = latest.work_date; await loadByDate(); window.scrollTo({ top:0, behavior:'smooth' });
  });

  $('btnDeleteDay')?.addEventListener('click', async ()=>{
    const { data:{ user } } = await sb.auth.getUser(); if(!user){ alert('No session. Try Link devices.'); return; }
    const d = $('date').value; if(!d){ alert('Pick a date first.'); return; }
    const { data: rowToDelete, error: fetchErr } = await sb.from('entries').select('*').eq('user_id',user.id).eq('work_date',d).maybeSingle();
    if(fetchErr && fetchErr.code!=='PGRST116'){ alert(fetchErr.message); return; }
    if(!rowToDelete){ alert('No entry exists for this date.'); return; }
    if(!confirm(`Delete your entry for ${d}? This cannot be undone (unless you press Undo).`)) return;
    const { error } = await sb.from('entries').delete().eq('user_id',user.id).eq('work_date',d); if(error){ alert(error.message); return; }
    lastDeleted = rowToDelete; showUndo(true);
    $('notes').value=''; parcels.value=0; letters.value=0; miles.value=53; offDay.checked=false; start.value='08:00'; end.value=''; departTime.value=''; returnTime.value=''; mood.value=''; weather.value=''; if(temp) temp.value=''; if(boxholders) boxholders.value=''; computeBreakdown();
    const rows = await fetchEntries();
    allRows = rows;
    rebuildAll();
    alert(`Deleted ${d}. You can Undo now.`);
  });

  btnUndoDelete?.addEventListener('click', async ()=>{
    if(!lastDeleted){ showUndo(false); return; }
    dWrite.textContent='—'; const { error } = await sb.from('entries').insert(lastDeleted);
    if(error){ alert('Undo failed: '+error.message); return; }
    const rows = await fetchEntries();
    allRows = rows;
    rebuildAll();
    alert(`Restored ${lastDeleted.work_date}.`); $('date').value = lastDeleted.work_date; await loadByDate(); lastDeleted=null; showUndo(false);
  });

  async function fetchEntries(){
    const { data:{ user } } = await sb.auth.getUser(); if(!user) return [];
    const { data, error } = await sb.from('entries').select('*').eq('user_id',user.id).order('work_date',{ascending:false}).limit(365);
    if(error){ console.error(error); return []; }
    return ensurePostHolidayTags(data || []);
  }

  function classifyRow(total, avg){ if(total==null||avg==null) return ''; const diff=(total-avg)/avg; if(diff<=-0.15) return 'light'; if(diff>=0.15) return 'heavy'; return 'typical'; }

  function renderTable(rows){
    rows = rows || [];
    const tbody=document.querySelector('#tbl tbody'); tbody.innerHTML='';
    __residModelCache = null;
    const model = getResidualModel(rows);
    const byDow=Array.from({length:7},()=>[]);
    rows.forEach(r=>{ if(r.status==='off') return; const h=Number(r.hours||0); const d=dowIndex(r.work_date); if(h>0) byDow[d].push(h); });
    const avgByDow=byDow.map(list=> list.length? (list.reduce((a,b)=>a+b,0)/list.length) : null);

    for(const r of rows){
      const tot=Number(r.hours||0)||null;
      const offH=(r.office_minutes!=null)? Number(r.office_minutes).toFixed(2):'';
      const rteH=(r.route_minutes!=null)? Number(r.route_minutes).toFixed(2):'';

      // NEW: weekday shorthand + moon phase
      const dObj = DateTime.fromISO(r.work_date, { zone: ZONE });
      const dowShort = dObj.toFormat('ccc').charAt(0); // M, T, W, T, F, S, S
      const moon = moonPhaseEmoji(r.work_date);

      const d=dowIndex(r.work_date);
      const avg=avgByDow[d];
      const cls=classifyRow(tot,avg);

      const tr=document.createElement('tr');
      tr.classList.add('rowLink');
      if(cls) tr.classList.add(cls);
      tr.dataset.date=r.work_date;
      tr.tabIndex=0;

      tr.innerHTML = `<td>${r.work_date}${vacMark(r.work_date)} (${dowShort}) ${moon}</td><td>R1</td><td>${r.status||'worked'}</td>
        <td class="right">${offH}</td><td class="right">${rteH}</td><td class="right">${tot!=null? tot.toFixed(2):''}</td>
        <td class="right">${r.parcels||0}</td><td class="right">${r.letters||0}</td><td class="right">${r.miles||0}</td>
        <td>${r.weather_json||''}</td><td></td>`;
      tbody.appendChild(tr);
    }
  }

  // Dynamic version tag with today's date (for exports)
  const VERSION_TAG = (function(){ try{ return 'v' + DateTime.now().setZone(ZONE).toFormat('yyyy-MM-dd'); }catch(_){ return 'v-current'; } })();
  function toCsv(rows){
    const headers=['work_date','route','status','start_time','depart_time','return_time','end_time','hours','office_minutes','route_minutes','parcels','letters','miles','mood','notes','weather_json','created_at'];
    const lines=[headers.join(',')];
    for(const r of rows){
      const vals=headers.map(h=>{ let v; if(h==='route') v='R1'; else v=r[h]; if(v==null) return ''; const s=String(v).replace(/"/g,'""'); return /[",\n]/.test(s)? '"'+s+'"': s; });
      lines.push(vals.join(','));
    }
    return lines.join('\n');
  }

  $('exportCsv').addEventListener('click', async ()=>{ const rows = allRows.length? allRows : await fetchEntries(); const blob=new Blob([toCsv(rows)],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`route-stats-all_${VERSION_TAG}.csv`; a.click(); });
  $('exportCsvFiltered').addEventListener('click', async ()=>{ const rows = applySearch(allRows.length? allRows : await fetchEntries()); const blob=new Blob([toCsv(rows)],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`route-stats-filtered_${VERSION_TAG}.csv`; a.click(); });

  const showUidBtn=$('showUid');
  showUidBtn?.addEventListener('click', async ()=>{ const { data:{ user } } = await sb.auth.getUser(); if(!user){ alert('No session. Use Link devices.'); return; } alert(`Current user id (account key):\n${user.id}\n\nEntries are filtered by this id.`); });

  const importFile=$('importFile'); $('importCsv')?.addEventListener('click', ()=> importFile.click());
  importFile?.addEventListener('change', async ()=>{
    const file=importFile.files?.[0]; if(!file) return; const text=await file.text();
    const lines=text.split(/\r?\n/).filter(Boolean); if(lines.length<2){ alert('CSV is empty'); return; }
    const headers=lines[0].split(',').map(h=> h.trim().replace(/^"|"$/g,'')); const idx=(n)=> headers.indexOf(n);
    const splitCsv=(row)=> row.split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/); const unq=(v)=> (/^".*"$/.test(v)? v.slice(1,-1).replace(/""/g,'"') : v);
    const { data:{ user } } = await sb.auth.getUser(); if(!user){ alert('No session. Use Link devices.'); return; }
    const rows=[]; for(let i=1;i<lines.length;i++){ const cols=splitCsv(lines[i]); const get=(name)=> unq(cols[idx(name)] ?? ''); const r={ user_id:user.id, work_date:get('work_date'), route:'R1', status:get('status')||'worked', start_time:get('start_time')||null, depart_time:get('depart_time')||null, return_time:get('return_time')||null, end_time:get('end_time')||null, hours:+(get('hours')||0)||null, office_minutes:get('office_minutes')||null, route_minutes:get('route_minutes')||null, parcels:+(get('parcels')||0)||0, letters:+(get('letters')||0)||0, miles:+(get('miles')||0)||0, mood:get('mood')||null, notes:get('notes')||null, weather_json:get('weather_json')||null }; if(r.work_date) rows.push(r); }
    if(!rows.length){ alert('No rows detected'); return; }
    const chunk=200; for(let i=0;i<rows.length;i+=chunk){ const slice=rows.slice(i,i+chunk); const { error } = await sb.from('entries').insert(slice); if(error){ alert('Import failed: '+error.message); return; } }
    const fresh = await fetchEntries();
    allRows = fresh;
    rebuildAll();
    alert(`Imported ${rows.length} rows into this account.`);
  });

  let dowChart, parcelsChart, lettersChart; function destroyCharts(){ [dowChart,parcelsChart,lettersChart].forEach(c=>c&&c.destroy()); }
  // Helper: make tapping the canvas set the nearest tooltip (mobile-friendly)
  function enableChartTap(chart, canvas){
    if (!chart || !canvas) return;
    const handler = (ev)=>{
      try{
        const rect = canvas.getBoundingClientRect();
        const cx = (ev.touches && ev.touches[0] ? ev.touches[0].clientX : ev.clientX);
        const cy = (ev.touches && ev.touches[0] ? ev.touches[0].clientY : ev.clientY);
        const x = cx - rect.left, y = cy - rect.top;
        const points = chart.getElementsAtEventForMode(ev, 'nearest', { intersect:false }, true);
        if (points && points.length){
          const a = [{ datasetIndex: points[0].datasetIndex, index: points[0].index }];
          if (chart.setActiveElements) chart.setActiveElements(a);
          if (chart.tooltip && chart.tooltip.setActiveElements) chart.tooltip.setActiveElements(a, { x, y });
          chart.update();
        }
      }catch(_){ /* ignore */ }
    };
    ['click','touchstart','pointerdown'].forEach(t => canvas.addEventListener(t, handler, { passive: true }));
  }

  function buildCharts(rows){
    rows = filterRowsForView(rows||[]);
    // If Chart.js isn't available, skip chart rendering so the rest of the app works
    if (!window.Chart) { console.warn('Chart.js missing — skipping charts'); return; }
    destroyCharts(); const workRows=rows.filter(r=>r.status!=='off');
    const byDow=Array.from({length:7},()=>({h:0,c:0}));
    for(const r of workRows){ const h=Number(r.hours||0); if(h>0){ const d=dowIndex(r.work_date); byDow[d].h+=h; byDow[d].c++; } }
    // Monday-first labels and data ordering (Mon..Sun)
    const dowLabels=['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
    const order=[1,2,3,4,5,6,0];
    const perDow=byDow.map(x=> x.c? +(x.h/x.c).toFixed(2):0);
    const dowData=order.map(i=> perDow[i]);
    dowChart=new Chart(document.getElementById('dowChart'),{
      type:'bar',
      data:{ labels:dowLabels, datasets:[{label:'Avg Total Hours',data:dowData}] },
      options:{ responsive:true, plugins:{ legend:{ display:false } } }
    });
    const sortedWork=[...workRows].sort((a,b)=> a.work_date.localeCompare(b.work_date)); const labels=sortedWork.map(r=> r.work_date);
    const parcelsCanvas = document.getElementById('parcelsChart');
    parcelsChart=new Chart(parcelsCanvas,{
      type:'line',
      data:{
        labels,
        datasets:[{ label:'Parcels', data: sortedWork.map(r=> +r.parcels||0), pointRadius:3, pointHoverRadius:8, pointHitRadius:16 }]
      },
      options: {
        responsive: true,
        interaction: { mode: 'nearest', intersect: false },
        events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
        animation: { duration: 0 },
        plugins: {
          legend: { display: false },
          tooltip: {
            animation: { duration: 0 },
            callbacks: {
              title: (items) => {
                const iso = items?.[0]?.label;
                if (!iso) return '';
                const d = DateTime.fromISO(iso, { zone: ZONE });
                return d.toFormat("cccc • MMM d, yyyy") + vacGlyph(iso);
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              maxRotation: 0,
              autoSkip: true,
              maxTicksLimit: 8,
              callback: function (value) {
                const iso = this.getLabelForValue(value);
                const d = DateTime.fromISO(iso, { zone: ZONE });
                return [d.toFormat('ccc'), d.toFormat('M/d')];
              }
            }
          }
        }
      }
    });
    const lettersCanvas = document.getElementById('lettersChart');
    lettersChart=new Chart(lettersCanvas,{
      type:'line',
      data:{
        labels,
        datasets:[{ label:'Letters', data: sortedWork.map(r=> +r.letters||0), pointRadius:3, pointHoverRadius:8, pointHitRadius:16 }]
      },
      options: {
        responsive: true,
        interaction: { mode: 'nearest', intersect: false },
        events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
        animation: { duration: 0 },
        plugins: {
          legend: { display: false },
          tooltip: {
            animation: { duration: 0 },
            callbacks: {
              title: (items) => {
                const iso = items?.[0]?.label;
                if (!iso) return '';
                const d = DateTime.fromISO(iso, { zone: ZONE });
                return d.toFormat("cccc • MMM d, yyyy") + vacGlyph(iso);
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              maxRotation: 0,
              autoSkip: true,
              maxTicksLimit: 8,
              callback: function (value) {
                const iso = this.getLabelForValue(value);
                const d = DateTime.fromISO(iso, { zone: ZONE });
                return [d.toFormat('ccc'), d.toFormat('M/d')];
              }
            }
          }
        }
      }
    });
    // Improve tap responsiveness on mobile
    enableChartTap(parcelsChart, parcelsCanvas);
    enableChartTap(lettersChart, lettersCanvas);
  }

  function hhmmFrom(baseDateStr, hours){ if(hours==null) return '—'; const d=DateTime.fromISO(baseDateStr,{zone:ZONE}).set({hour:8,minute:0}); return d.plus({hours}).toFormat('h:mm a'); }

  function buildSnapshot(rows){
    rows = filterRowsForView(rows||[]);
    const today=DateTime.now().setZone(ZONE);
    const dow=today.weekday%7; // 0=Sun
    const workRows=rows.filter(r=>r.status!=='off');

    // Baselines by DOW for expected end
    const byDow=Array.from({length:7},()=>({h:0,c:0}));
    for(const r of workRows){ const h=Number(r.hours||0); if(h>0){ const d=dowIndex(r.work_date); byDow[d].h+=h; byDow[d].c++; } }
    const avgH=byDow.map(x=> x.c? x.h/x.c : null); const todayAvgH=avgH[dow];
    expEnd.textContent = todayAvgH? hhmmFrom(today.toISODate(), todayAvgH) : '—';
    expMeta.textContent = `${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][dow]} avg ${todayAvgH? todayAvgH.toFixed(2)+'h':'—'}`;
    // Enable click-to-toggle help on snapshot tiles (once)
    (function enableTileHelp(){
      try{
        const pairs = [
          { id:'badgeVolume', help:'helpVolume' },
          { id:'badgeRouteEff', help:'helpRouteEff' },
          { id:'badgeOverall', help:'helpOverall' },
        ];
        pairs.forEach(p => {
          const badge = document.getElementById(p.id);
          const help = document.getElementById(p.help);
          const tile = badge?.closest('.stat');
          if (!badge || !help || !tile) return;
          if (tile.dataset.helpReady) return; // attach once
          tile.dataset.helpReady = '1';
          tile.style.cursor = 'pointer';
          tile.setAttribute('tabindex','0');
          const toggle = ()=>{ help.style.display = (help.style.display==='none'||!help.style.display)? 'block':'none'; };
          tile.addEventListener('click', (e)=>{
            // ignore clicks on links/buttons inside
            if (e.target.closest('button,a,input,select,textarea')) return;
            toggle();
          });
          tile.addEventListener('keydown', (e)=>{ if (e.key==='Enter'||e.key===' '){ e.preventDefault(); toggle(); } });
        });
      }catch(_){ }
    })();

    // Badges (volume, route eff, overall) — align with leaderboard (all worked days, learned letter weight)
    const letterW = CURRENT_LETTER_WEIGHT || 0.33;
    const volMetric = (r)=> combinedVolume(r.parcels||0, r.letters||0, letterW);
    const vols = workRows.map(volMetric);
    const v = vols.length? volMetric(workRows[0]||{}):0;
    const rank = (arr,x)=>{
      const s=[...arr].sort((a,b)=>a-b);
      let idx = s.findIndex(n=> x <= n);
      if (idx < 0) idx = s.length - 1;
      return (idx + 1) / s.length;
    };
    const volScore10 = vols.length? Math.round(rank(vols,v)*10) : null;
    if (volScore10==null) badgeVolume.textContent = '—'; else badgeVolume.textContent = `${volScore10}/10`;
    try{
    if (vols.length){
        const s=[...vols].sort((a,b)=>a-b); const min=s[0], max=s[s.length-1];
        const mid = Math.floor(s.length/2); const med = s.length%2? s[mid] : (s[mid-1]+s[mid])/2;
        const pct = Math.round(rank(vols,v)*100);
        const volTip = `Volume today: ${v.toFixed(1)} (parcels + ${letterW.toFixed(2)}×letters)\nScore: ${volScore10}/10 ≈ ${pct}th percentile of ${vols.length} worked day(s)\nRange: min ${min.toFixed(1)} • median ${med.toFixed(1)} • max ${max.toFixed(1)}`;
        badgeVolume.title = volTip;
        try{ const tile = badgeVolume.closest('.stat'); if (tile) tile.title = volTip; }catch(_){ }
        const hv = document.getElementById('helpVolume');
        if (hv) hv.textContent = `Rank (all-time): ${volScore10}/10 (~${pct}th percentile). Today ${v.toFixed(1)}; min ${min.toFixed(1)}, median ${med.toFixed(1)}, max ${max.toFixed(1)}.`;
      }
    }catch(_){ }
    const rhs = workRows
      .filter(r=> dowIndex(r.work_date)===dow)
      .map(r=> routeAdjustedHours(r))
      .filter(n=>n>0);
    const rteAvg = rhs.length? (rhs.reduce((a,b)=>a+b,0)/rhs.length) : null;
    const todayRoute = workRows[0]? routeAdjustedHours(workRows[0]) : null;
    const rteScore = (rteAvg && todayRoute!=null && rteAvg>0)? Math.max(0, Math.min(10, Math.round((1 - (todayRoute - rteAvg)/Math.max(1,rteAvg))*10))) : 0;
    badgeRouteEff.textContent = `${rteScore}/10`;
    try{
      const deltaPct = (rteAvg && todayRoute!=null && rteAvg>0)? Math.round(((todayRoute - rteAvg)/rteAvg)*100) : null;
      const adjNote = `adjusted −${boxholderAdjMinutes(workRows[0])||0}m (≈${(boxholderAdjMinutes(workRows[0])||0)/60}h) for boxholders`;
      badgeRouteEff.title = `Route minutes (adjusted): ${todayRoute!=null?Math.round(todayRoute):'—'} vs weekday avg ${rteAvg!=null?Math.round(rteAvg):'—'}\nΔ vs avg: ${deltaPct==null?'—':(deltaPct>=0?('+'+deltaPct):('−'+Math.abs(deltaPct)))}%\nScore: ${rteScore}/10 (higher is better)\nNote: ${adjNote}`;
      const hr = document.getElementById('helpRouteEff');
      if (hr){
        hr.innerHTML = `Adjusted route min vs weekday avg.<br>Today ${todayRoute!=null?Math.round(todayRoute):'—'} vs avg ${rteAvg!=null?Math.round(rteAvg):'—'}. Score ${rteScore}/10.
          <br><button id=\"linkRouteEffDetails\" class=\"ghost btn-compact\" type=\"button\">Open Weekly Compare</button>`;
        setTimeout(()=>{
          const btn = document.getElementById('linkRouteEffDetails');
          if (btn){ btn.onclick = (e)=>{ e.preventDefault(); try{ document.getElementById('mixVizCard')?.scrollIntoView({ behavior:'smooth', block:'start' }); }catch(_){ } }; }
        },0);
      }
    }catch(_){ }
    const totToday = workRows[0]? (+workRows[0].hours||0) : 0; const exp = todayAvgH || 0; const overallScore = exp>0? Math.max(0, Math.min(10, Math.round((1 - (totToday - exp)/Math.max(1,exp))*10))) : 0; badgeOverall.textContent = `${overallScore}/10`;
    try{
      const deltaPctTot = exp>0? Math.round(((totToday - exp)/exp)*100) : null;
      badgeOverall.title = `Total hours: ${totToday.toFixed(2)} vs expected ${exp?exp.toFixed(2):'—'} (weekday avg)\nΔ vs expected: ${deltaPctTot==null?'—':(deltaPctTot>=0?('+'+deltaPctTot):('−'+Math.abs(deltaPctTot)))}%\nScore: ${overallScore}/10 (higher is better)`;
      const ho = document.getElementById('helpOverall');
      if (ho) ho.textContent = `Total hours vs weekday expected. Today ${totToday.toFixed(2)}h vs exp ${exp?exp.toFixed(2)+'h':'—'}. Score ${overallScore}/10.`;
    }catch(_){ }

    const todayRow = workRows[0] || null;
    const tripRaw = todayRow ? parseSecondTripFromRow(todayRow) : null;
    const evalHourly = getHourlyRateFromEval();
    let extraTrip = null;
    if (tripRaw){
      const miles = Math.max(0, +tripRaw.m || 0);
      const actual = Math.max(0, +tripRaw.t || 0);
      const emaRaw = (tripRaw.e!=null && tripRaw.e!=='') ? +tripRaw.e : NaN;
      const emaVal = Number.isFinite(emaRaw) && emaRaw >= 0 ? emaRaw : readStoredEma();
      if ((miles > 0) || (actual > 0)){
        const paidMinutes = miles * 2;
        const gas = miles * emaVal;
        const timePay = evalHourly!=null ? (paidMinutes/60) * evalHourly : null;
        const payout = gas + (timePay || 0);
        extraTrip = {
          miles,
          actual,
          ema: emaVal,
          paidMinutes,
          gas,
          timePay,
          payout
        };
      }
    }

    try{
      const tile = document.getElementById('extraTripTodayTile');
      const valEl = document.getElementById('extraTripTodayVal');
      const metaEl = document.getElementById('extraTripTodayMeta');
      if (tile && valEl && metaEl){
        if (!extraTrip){
          tile.style.display = 'none';
        } else {
          tile.style.display = '';
          valEl.textContent = `$${extraTrip.payout.toFixed(2)}`;
          const metaParts = [];
          metaParts.push(`${extraTrip.miles.toFixed(1)} mi`);
          metaParts.push(`Paid ${extraTrip.paidMinutes.toFixed(0)}m`);
          if (extraTrip.actual > 0) metaParts.push(`Actual ${extraTrip.actual.toFixed(0)}m`);
          metaParts.push(`Gas $${extraTrip.gas.toFixed(2)}`);
          if (extraTrip.timePay != null) metaParts.push(`Time $${extraTrip.timePay.toFixed(2)}`);
          metaEl.textContent = metaParts.join(' · ');
          tile.title = `Miles ${extraTrip.miles.toFixed(2)} · Paid ${extraTrip.paidMinutes.toFixed(0)}m · Actual ${extraTrip.actual.toFixed(0)}m · EMA $${extraTrip.ema.toFixed(2)}/mi`;
        }
      }
    }catch(_){ }

    try{
      const tile = document.getElementById('todayHourlyTile');
      const valEl = document.getElementById('todayHourlyRate');
      const metaEl = document.getElementById('todayHourlyMeta');
      if (tile && valEl && metaEl){
        if (evalHourly == null || !(totToday > 0)){
          tile.style.display = 'none';
        } else {
          const basePay = evalHourly * totToday;
          const extraPay = extraTrip ? extraTrip.payout : 0;
          const runRate = (basePay + extraPay) / Math.max(totToday, 0.01);
          tile.style.display = '';
          valEl.textContent = `$${runRate.toFixed(2)}`;
          const metaParts = [`Base $${basePay.toFixed(2)}`];
          if (extraPay > 0){
            metaParts.push(`Extra $${extraPay.toFixed(2)}`);
          }
          metaParts.push(`${totToday.toFixed(2)}h`);
          metaEl.textContent = metaParts.join(' · ');
          const lines = [`Base pay (est.): $${basePay.toFixed(2)} for ${totToday.toFixed(2)}h (@ $${evalHourly.toFixed(2)}/h)`];
          if (extraTrip){
            const timeLine = extraTrip.timePay != null ? `Time $${extraTrip.timePay.toFixed(2)}` : null;
            const extras = [`Gas $${extraTrip.gas.toFixed(2)}`];
            if (timeLine) extras.push(timeLine);
            lines.push(`Extra trip payout: $${extraTrip.payout.toFixed(2)} (${extras.join(' + ')})`);
          }
          tile.title = lines.join('\n');
        }
      }
    }catch(_){ }

    // ===== Weekly tiles (Monday-based) =====
    const weekStart = startOfWeekMonday(today);
    const weekEnd   = today.endOf('day');
    const prevWeekStart = startOfWeekMonday(today.minus({weeks:1}));
    const prevWeekEnd   = endOfWeekSunday(today.minus({weeks:1}));
    const priorWeekStart = startOfWeekMonday(today.minus({weeks:2}));
    const priorWeekEnd   = endOfWeekSunday(today.minus({weeks:2}));

    const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
    const sum=(arr,fn)=>arr.reduce((t,x)=>t+(fn(x)||0),0);

    const thisW = workRows.filter(r=> inRange(r,weekStart,weekEnd));
    const lastW = workRows.filter(r=> inRange(r,prevWeekStart,prevWeekEnd));
    const priorW= workRows.filter(r=> inRange(r,priorWeekStart,priorWeekEnd));

    const daysWorked = arr=> arr.filter(r=> (r.hours||0)>0).length;
    const dThis = daysWorked(thisW), dLast = daysWorked(lastW), dPrior = daysWorked(priorW);

    const hThis=sum(thisW,r=>+r.hours||0), pThis=sum(thisW,r=>+r.parcels||0), lThis=sum(thisW,r=>+r.letters||0);
    const hLast=sum(lastW,r=>+r.hours||0), pLast=sum(lastW,r=>+r.parcels||0), lLast=sum(lastW,r=>+r.letters||0);

    // Show live totals as "thisWeek / lastWeek"
    $('wkHours').textContent   = `${(hThis||0).toFixed(2)} / ${(hLast||0).toFixed(2)}`;
    $('wkParcels').textContent = `${pThis||0} / ${pLast||0}`;
    $('wkLetters').textContent = `${lThis||0} / ${lLast||0}`;

    // Carry-forward percentage = last full week's % vs prior week (per-worked-day averages)
    const avgOrNull=(tot,days)=> days? tot/days : null;
    const pct=(a,b)=> (a==null||b==null||b===0)? null : ((a-b)/b)*100;

    const hCarry = pct(avgOrNull(hLast,dLast), avgOrNull(sum(priorW,r=>+r.hours||0), dPrior));
    const pCarry = pct(avgOrNull(pLast,dLast), avgOrNull(sum(priorW,r=>+r.parcels||0), dPrior));
    const lCarry = pct(avgOrNull(lLast,dLast), avgOrNull(sum(priorW,r=>+r.letters||0), dPrior));

    // Current-week target % vs last week (per-worked-day averages so far)
    const hTarget = pct(avgOrNull(hThis,dThis), avgOrNull(hLast,dLast));
    const pTarget = pct(avgOrNull(pThis,dThis), avgOrNull(pLast,dLast));
    const lTarget = pct(avgOrNull(lThis,dThis), avgOrNull(lLast,dLast));

    // Blend from carry-forward toward current as the week progresses (Mon..Fri ≈ 5 workdays)
    const progress = Math.min(1, dThis/5);
    const blend=(carry,target)=> (carry==null && target==null)? null : (carry==null? target : target==null? carry : carry*(1-progress) + target*progress);

    const dh = blend(hCarry, hTarget);
    const dp = blend(pCarry, pTarget);
    const dl = blend(lCarry, lTarget);

    const fmt = p => {
      if (p == null) return '—';
      const rounded = Math.round(p);
      return rounded >= 0 ? `↑ ${rounded}%` : `↓ ${Math.abs(rounded)}%`;
    };

    const setPill=(el,delta)=>{
      el.textContent = fmt(delta);
      el.className = 'pill';
      const { fg } = colorForDelta(delta || 0);
      el.style.color = fg || 'var(--text)';
      el.style.background = 'transparent';
      el.style.borderColor = 'transparent';
    };
    setPill($('wkHoursDelta'),   dh);
    setPill($('wkParcelsDelta'), dp);
    setPill($('wkLettersDelta'), dl);

    // Extra trip weekly totals
    const extraMilesEl = document.getElementById('extraMilesWeekVal');
    const extraTimeEl = document.getElementById('extraTimeWeekVal');
    const extraPayoutEl = document.getElementById('extraPayoutWeekVal');
    const extraTiles = [document.getElementById('extraMilesWeek'), document.getElementById('extraTimeWeek'), document.getElementById('extraPayoutWeek')];
    const tripsThisWeek = (rows||[]).map(r=> ({ row:r, data: parseSecondTripFromRow(r) }))
      .filter(entry => entry.data && inRange(entry.row, weekStart, weekEnd));
    if (!tripsThisWeek.length){
      extraTiles.forEach(el=>{ if (el) el.style.display=''; });
      if (extraMilesEl) extraMilesEl.textContent = '0 mi';
      if (extraTimeEl){
        extraTimeEl.textContent = '0 min';
        extraTimeEl.title = 'No extra trips logged yet';
      }
      if (extraPayoutEl){
        extraPayoutEl.textContent = '$0.00';
        extraPayoutEl.title = 'No extra trips logged yet';
      }
    } else {
      const totalMiles = tripsThisWeek.reduce((sum, entry)=> sum + (+entry.data.m || 0), 0);
      const totalActual = tripsThisWeek.reduce((sum, entry)=> sum + (+entry.data.t || 0), 0);
      const totalPaid = tripsThisWeek.reduce((sum, entry)=> sum + ((+entry.data.m || 0) * 2), 0);
      const totalGas = tripsThisWeek.reduce((sum, entry)=>{
        const miles = +entry.data.m || 0;
        const emaRaw = entry.data?.e;
        const ema = Number.isFinite(+emaRaw) && +emaRaw >= 0 ? +emaRaw : readStoredEma();
        return sum + (miles * ema);
      }, 0);
      const hourlyRate = getHourlyRateFromEval();
      const timeComp = hourlyRate!=null ? (totalPaid/60) * hourlyRate : null;
      const payout = (timeComp!=null ? timeComp : 0) + totalGas;

      if (extraTiles[0]) extraTiles[0].style.display = '';
      if (extraTiles[1]) extraTiles[1].style.display = '';
      if (extraTiles[2]) extraTiles[2].style.display = '';

      if (extraMilesEl) extraMilesEl.textContent = `${totalMiles.toFixed(1)} mi`;
      if (extraTimeEl) {
        const paidNote = totalPaid.toFixed(0);
        extraTimeEl.textContent = `${totalActual.toFixed(0)} min`;
        extraTimeEl.title = `Actual minutes: ${totalActual.toFixed(0)} · Paid minutes: ${paidNote}`;
      }
      if (extraPayoutEl){
        extraPayoutEl.textContent = `$${payout.toFixed(2)}`;
        extraPayoutEl.title = timeComp!=null
          ? `Gas: $${totalGas.toFixed(2)} · Time pay: $${timeComp.toFixed(2)}`
          : `Gas: $${totalGas.toFixed(2)} · Add salary in Settings to include paid time`; 
      }
    }

    // ===== Advanced Weekly Metrics (Phase 1) =====
    // Day-by-day comparison Mon..today vs same weekday last week,
    // then compute weighted average and cumulative impact (percent).
    const dayIndexToday = (today.weekday + 6) % 7; // Mon=0..Sun=6

    // Build arrays for this week and last week by weekday index (Mon..Sun)
    const toWeekArray = (from, to) => {
      const out = Array.from({ length: 7 }, () => ({ h: 0, p: 0, l: 0 }));
      const inRange = (r) => {
        const d = DateTime.fromISO(r.work_date, { zone: ZONE });
        return d >= from && d <= to;
      };
      workRows.filter(inRange).forEach(r => {
        const d = DateTime.fromISO(r.work_date, { zone: ZONE });
        const idx = (d.weekday + 6) % 7; // Mon=0
        const h = +r.hours || 0;
        const p = +r.parcels || 0;
        const l = +r.letters || 0;
        out[idx].h += h; out[idx].p += p; out[idx].l += l;
      });
      return out;
    };
    const thisWeek = toWeekArray(weekStart, weekEnd);
    const lastWeek = toWeekArray(prevWeekStart, prevWeekEnd);

    // Holiday adjustment detection: if Monday of this week is an explicit off day,
    // treat Tuesday's baseline as (Mon+Tue of last week). Controlled by flag.
    const holidayAdjEnabled = !!(FLAGS && FLAGS.holidayAdjustments);
    // Detect holiday off-days within current week. If found, adjust the NEXT day's baseline
    const carryNext = new Set();
    if (holidayAdjEnabled) {
      try{
        const inWeek = (r)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=weekStart && d<=weekEnd; };
        const isHolidayMarked = (r)=> /(^|\b)Holiday(\b|$)/i.test(String(r.weather_json||''));
        rows.filter(r=> r.status==='off' && inWeek(r) && isHolidayMarked(r)).forEach(r=>{
          const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; if (idx<6) carryNext.add(idx+1);
        });
      }catch(_){ /* ignore */ }
    }

    // Off-day detection for current week (so we don't show -100% on off days)
    const offIdxThisWeek = new Set(rows
      .filter(r => r.status === 'off' && inRange(r, weekStart, weekEnd))
      .map(r => (DateTime.fromISO(r.work_date, { zone: ZONE }).weekday + 6) % 7));

    const dailyDeltas = (key) => {
      const arr = [];
      for (let i = 0; i <= dayIndexToday && i < 7; i++) {
        const cur = offIdxThisWeek.has(i) ? null : thisWeek[i][key];
        let base = lastWeek[i][key];
        if (holidayAdjEnabled && carryNext.has(i)) {
          // Baseline for day after a holiday off-day = last week (prev day + this day)
          base = ((lastWeek[i-1]?.[key] || 0) + (lastWeek[i]?.[key] || 0));
        }
        arr.push(cur == null ? null : pct(cur || 0, base || 0));
      }
      return arr; // may include nulls
    };
    const dH = dailyDeltas('h');
    const dP = dailyDeltas('p');
    const dL = dailyDeltas('l');

    const weightedAvg = (arr) => {
      let s = 0, wsum = 0;
      for (let i = 0; i < arr.length; i++) {
        const v = arr[i]; if (v == null || !isFinite(v)) continue;
        const w = i + 1; s += v * w; wsum += w;
      }
      return wsum ? (s / wsum) : null;
    };
    const cumulative = (arr) => {
      let s = 0, seen = false;
      for (const v of arr) { if (v == null || !isFinite(v)) continue; s += v; seen = true; }
      return seen ? s : null;
    };

    const advH = weightedAvg(dH);
    const advP = weightedAvg(dP);
    const advL = weightedAvg(dL);
    const cumH = cumulative(dH);
    const cumP = cumulative(dP);
    const cumL = cumulative(dL);

    // Same-Count Weekly Average: compare N worked days this week vs first N worked days last week
    function sameCountDelta(key){
      const cur = [];
      for (let i = 0; i <= dayIndexToday && i < 7; i++){
        const v = thisWeek[i]?.[key] || 0; if (v>0) cur.push(v);
      }
      const N = cur.length;
      const prior = [];
      for (let i = 0; i < 7; i++){
        const v = lastWeek[i]?.[key] || 0; if (v>0) prior.push(v);
      }
      const M = prior.length;
      if (!N || !M) return { delta:null, n:N, m:M, avgThis:null, avgLast:null };
      const nUse = Math.min(N, M);
      const sumArr = a => a.reduce((t,x)=>t+(+x||0),0);
      const avgThis = sumArr(cur) / N;
      const avgLast = sumArr(prior.slice(0, nUse)) / nUse;
      const delta = pct(avgThis, avgLast);
      return { delta, n:N, m:M, avgThis, avgLast };
    }
    const scH = sameCountDelta('h');
    const scP = sameCountDelta('p');
    const scL = sameCountDelta('l');

    // Display as combined cue: prefer weighted average; fallback to cumulative
    const pick = (sc, w, c) => (sc!=null ? sc : (w != null ? w : c));
    setPill($('advHoursTrend'),   pick(scH.delta, advH, cumH));
    setPill($('advParcelsTrend'), pick(scP.delta, advP, cumP));
    setPill($('advLettersTrend'), pick(scL.delta, advL, cumL));

    // ===== Populate Weekly Hours Details panel =====
    try {
      const panelBody = document.getElementById('wkHoursDetailsBody');
      if (panelBody) {
        // Use precomputed Mon..Sun buckets from Advanced Weekly Metrics
        
        const dNames = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
        const rowsHtml = [];
        let tThis = 0, tLast = 0;
        for (let i = 0; i < 7; i++) {
          const cur = (i <= dayIndexToday) ? (offIdxThisWeek.has(i) ? null : (thisWeek[i]?.h || 0)) : null; // only Mon..today for this week; off-day shows as null
          let base = lastWeek[i]?.h || 0;
          let adjMark = '';
          if (holidayAdjEnabled && carryNext && carryNext.has(i)) { base = (lastWeek[i-1]?.h||0) + (lastWeek[i]?.h||0); adjMark = ' (adj)'; }
          if (cur != null) tThis += cur;
          if (i <= dayIndexToday) tLast += base;
          const delta = (cur == null || base === 0) ? null : ((cur - base) / base) * 100;
          const curTxt = (cur == null) ? 'Off' : cur.toFixed(2);
          const baseTxt = (base === 0) ? 'Off' : base.toFixed(2);
          const { fg } = colorForDelta(delta || 0);
          const deltaTxt = (delta == null) ? '—' : (delta >= 0 ? `↑ ${Math.round(delta)}%` : `↓ ${Math.abs(Math.round(delta))}%`);
          rowsHtml.push(`<tr><td>${dNames[i]}${adjMark}</td><td class="right">${curTxt}</td><td class="right">${baseTxt}</td><td class="right" style="color:${fg};white-space:nowrap">${deltaTxt}</td></tr>`);
        }
        const totalDelta = (tLast === 0) ? null : ((tThis - tLast) / tLast) * 100;
        const { fg:totFg } = colorForDelta(totalDelta || 0);
        const totalRow = `<tr><th>Total</th><th class="right">${tThis.toFixed(2)}</th><th class="right">${tLast.toFixed(2)}</th><th class="right" style="color:${totFg}">${totalDelta==null?'—':(totalDelta>=0?`↑ ${Math.round(totalDelta)}%`:`↓ ${Math.abs(Math.round(totalDelta))}%`)}</th></tr>`;

        const summaryHtml = `<small><span>This week so far: </span><span style=\"color:var(--warn)\">${tThis.toFixed(2)}h over ${dThis} day(s). Last week: ${tLast.toFixed(2)}h over ${dLast} day(s).</span></small>`;

        panelBody.innerHTML = `
          <div style=\"padding:8px 10px;border-bottom:1px solid var(--border)\">${summaryHtml}</div>
          <table style="width:100%;border-collapse:collapse">
            <thead>
              <tr><th>Day</th><th class="right">This week</th><th class="right">Last week</th><th class="right">Δ%</th></tr>
            </thead>
            <tbody>
              ${rowsHtml.join('')}
            </tbody>
            <tfoot>
              ${totalRow}
            </tfoot>
          </table>
        `;
      }
    } catch (e) {
      console.warn('Failed to populate weekly hours details', e);
    }

    // ===== Populate Weekly Parcels Details panel =====
    try {
      const panelBody = document.getElementById('wkParcelsDetailsBody');
      if (panelBody) {
        const dNames = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
        const rowsHtml = [];
        let tThis = 0, tLast = 0;
        for (let i = 0; i < 7; i++) {
          const cur = (i <= dayIndexToday) ? (offIdxThisWeek.has(i) ? null : (thisWeek[i]?.p || 0)) : null;
          let base = lastWeek[i]?.p || 0;
          let adjMark = '';
          if (holidayAdjEnabled && carryNext && carryNext.has(i)) { base = (lastWeek[i-1]?.p||0) + (lastWeek[i]?.p||0); adjMark=' (adj)'; }
          if (cur != null) tThis += cur;
          if (i <= dayIndexToday) tLast += base;
          const delta = (cur == null || base === 0) ? null : ((cur - base) / base) * 100;
          const curTxt = (cur == null) ? '—' : String(cur);
          const baseTxt = String(base); // show 0 explicitly
          const { fg } = colorForDelta(delta || 0);
          const deltaTxt = (delta == null) ? '—' : (delta >= 0 ? `↑ ${Math.round(delta)}%` : `↓ ${Math.abs(Math.round(delta))}%`);
          rowsHtml.push(`<tr><td>${dNames[i]}${adjMark}</td><td class="right">${curTxt}</td><td class="right">${baseTxt}</td><td class="right" style="color:${fg};white-space:nowrap">${deltaTxt}</td></tr>`);
        }
        const totalDelta = (tLast === 0) ? null : ((tThis - tLast) / tLast) * 100;
        const { fg:totFg } = colorForDelta(totalDelta || 0);
        const totalRow = `<tr><th style=\"color:var(--brand)\">Total (this week vs last)</th><th class=\"right\">${tThis}</th><th class=\"right\">${tLast}</th><th class=\"right\" style=\"color:${totFg}\">${totalDelta==null?'—':(totalDelta>=0?`↑ ${Math.round(totalDelta)}%`:`↓ ${Math.abs(Math.round(totalDelta))}%`)}</th></tr>`;
        const summaryHtml = `<small><span>This week so far: </span><span style=\"color:var(--warn)\">${tThis} parcels over ${dThis} day(s). Last week: ${tLast} parcels over ${dLast} day(s).</span></small>`;
        panelBody.innerHTML = `
          <div style=\"padding:8px 10px;border-bottom:1px solid var(--border)\">${summaryHtml}</div>
          <table style=\"width:100%;border-collapse:collapse\">
            <thead><tr><th>Day</th><th class=\"right\">This week</th><th class=\"right\">Last week</th><th class=\"right\">Δ%</th></tr></thead>
            <tbody>${rowsHtml.join('')}</tbody>
            <tfoot>${totalRow}</tfoot>
          </table>`;
      }
    } catch (e) {
      console.warn('Failed to populate weekly parcels details', e);
    }

    // ===== Populate Weekly Letters Details panel =====
    try {
      const panelBody = document.getElementById('wkLettersDetailsBody');
      if (panelBody) {
        const dNames = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
        const rowsHtml = [];
        let tThis = 0, tLast = 0;
        for (let i = 0; i < 7; i++) {
          const cur = (i <= dayIndexToday) ? (offIdxThisWeek.has(i) ? null : (thisWeek[i]?.l || 0)) : null;
          let base = lastWeek[i]?.l || 0;
          let adjMark = '';
          if (holidayAdjEnabled && carryNext && carryNext.has(i)) { base = (lastWeek[i-1]?.l||0) + (lastWeek[i]?.l||0); adjMark=' (adj)'; }
          if (cur != null) tThis += cur;
          if (i <= dayIndexToday) tLast += base;
          const delta = (cur == null || base === 0) ? null : ((cur - base) / base) * 100;
          const curTxt = (cur == null) ? '—' : String(cur);
          const baseTxt = String(base); // show 0 explicitly
          const { fg } = colorForDelta(delta || 0);
          const deltaTxt = (delta == null) ? '—' : (delta >= 0 ? `↑ ${Math.round(delta)}%` : `↓ ${Math.abs(Math.round(delta))}%`);
          rowsHtml.push(`<tr><td>${dNames[i]}${adjMark}</td><td class="right">${curTxt}</td><td class="right">${baseTxt}</td><td class="right" style="color:${fg};white-space:nowrap">${deltaTxt}</td></tr>`);
        }
        const totalDelta = (tLast === 0) ? null : ((tThis - tLast) / tLast) * 100;
        const { fg:totFg } = colorForDelta(totalDelta || 0);
        const totalRow = `<tr><th style=\"color:var(--brand)\">Total (this week vs last)</th><th class=\"right\">${tThis}</th><th class=\"right\">${tLast}</th><th class=\"right\" style=\"color:${totFg}\">${totalDelta==null?'—':(totalDelta>=0?`↑ ${Math.round(totalDelta)}%`:`↓ ${Math.abs(Math.round(totalDelta))}%`)}</th></tr>`;
        const summaryHtml = `<small><span>This week so far: </span><span style=\"color:var(--warn)\">${tThis} letters over ${dThis} day(s). Last week: ${tLast} letters over ${dLast} day(s).</span></small>`;
        panelBody.innerHTML = `
          <div style=\"padding:8px 10px;border-bottom:1px solid var(--border)\">${summaryHtml}</div>
          <table style=\"width:100%;border-collapse:collapse\">
            <thead><tr><th>Day</th><th class=\"right\">This week</th><th class=\"right\">Last week</th><th class=\"right\">Δ%</th></tr></thead>
            <tbody>${rowsHtml.join('')}</tbody>
            <tfoot>${totalRow}</tfoot>
          </table>`;
      }
    } catch (e) {
      console.warn('Failed to populate weekly letters details', e);
    }

    // ===== Populate Advanced Weekly Trend panels (H/P/L) =====
    const renderTrendPanel = (bodyId, dailyArr, weightedVal, cumulativeVal, key, sc) => {
      const body = document.getElementById(bodyId);
      if (!body) return;
      const days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
      const rows = [];
      for (let i = 0; i <= dayIndexToday && i < 7; i++) {
        const v = dailyArr[i];
        const cur = offIdxThisWeek.has(i) ? null : (thisWeek[i]?.[key] || 0);
        let base = lastWeek[i]?.[key] || 0;
        let adjMark = '';
        if (holidayAdjEnabled && carryNext && carryNext.has(i)) { base = (lastWeek[i-1]?.[key]||0) + (lastWeek[i]?.[key]||0); adjMark=' (adj)'; }
        const pctTxt = (v == null || !isFinite(v)) ? '—' : (v >= 0 ? `↑ ${Math.round(v)}%` : `↓ ${Math.abs(Math.round(v))}%`);
        const { fg } = colorForDelta(v || 0);
        const fmt = key === 'h' ? (n)=> n.toFixed(2) : (n)=> String(n);
        const curTxt = (i <= dayIndexToday) ? (cur==null ? (key==='h'?'Off':'—') : fmt(cur)) : '—';
        const baseTxt = (key === 'h') ? ((base === 0) ? 'Off' : fmt(base)) : fmt(base);
        rows.push(`<tr><td>${days[i]}${adjMark}</td><td class="right">${curTxt}</td><td class="right">${baseTxt}</td><td class="right" style="color:${fg};white-space:nowrap">${pctTxt}</td></tr>`);
      }
      const pickUsed = (sc && sc.delta != null && isFinite(sc.delta)) ? `Weekly Avg (N=${sc.n}${(sc.m&&sc.m!==sc.n)?`, last N=${Math.min(sc.n, sc.m)}`:''})` : ((weightedVal != null && isFinite(weightedVal)) ? 'Weighted' : 'Cumulative');
      const wTxt = (weightedVal == null || !isFinite(weightedVal)) ? '—' : `${weightedVal>=0?'↑':'↓'} ${Math.abs(Math.round(weightedVal))}%`;
      const cTxt = (cumulativeVal == null || !isFinite(cumulativeVal)) ? '—' : `${cumulativeVal>=0?'↑':'↓'} ${Math.abs(Math.round(cumulativeVal))}%`;
      const sTxt = (!sc || sc.delta == null || !isFinite(sc.delta)) ? '—' : `${sc.delta>=0?'↑':'↓'} ${Math.abs(Math.round(sc.delta))}%`;
      const { fg: sFg } = colorForDelta((sc && sc.delta) || 0);
      const { fg: wFg } = colorForDelta(weightedVal || 0);
      const { fg: cFg } = colorForDelta(cumulativeVal || 0);
      body.innerHTML = `
        <table style="width:100%;border-collapse:collapse">
          <thead><tr><th>Day</th><th class=\"right\">This week</th><th class=\"right\">Last week</th><th class=\"right\">Δ%</th></tr></thead>
          <tbody>${rows.join('')}</tbody>
          <tfoot>
            <tr><th colspan=\"3\" class=\"right\">Weekly Avg Δ% ${sc ? `<small class=\\"muted\\">(N=${sc.n}${(sc.m&&sc.m!==sc.n)?`, last N=${Math.min(sc.n, sc.m)}`:''})</small>` : ''}</th><th class=\"right\" style=\"color:${sFg}\">${sTxt}</th></tr>
            <tr><th colspan=\"3\" class=\"right\">Weighted avg Δ%</th><th class=\"right\" style=\"color:${wFg}\">${wTxt}</th></tr>
            <tr><th colspan=\"3\" class=\"right\">Cumulative Δ%</th><th class=\"right\" style=\"color:${cFg}\">${cTxt}</th></tr>
            <tr><th colspan=\"4\" class=\"right\"><small class=\"muted\">Using: ${pickUsed}</small></th></tr>
          </tfoot>
        </table>`;
    };
    try {
      renderTrendPanel('advHoursDetailsBody', dH, advH, cumH, 'h', scH);
      renderTrendPanel('advParcelsDetailsBody', dP, advP, cumP, 'p', scP);
      renderTrendPanel('advLettersDetailsBody', dL, advL, cumL, 'l', scL);
    } catch (e) {
      console.warn('Failed to populate trend panels', e);
    }

    // Today vs same-weekday baseline (worked days only)
    const todayIso = today.toISODate();
    const todaysRow = workRows.find(r => r.work_date === todayIso);
    const sameDow = workRows.filter(r => r.work_date !== todayIso && (dowIndex(r.work_date) === dow));
    // Use last same-weekday (most recent prior) as baseline instead of multi-week average
    const lastSame = sameDow.length ? sameDow[0] : null;
    const baseParcels = lastSame ? (+lastSame.parcels||0) : null;
    const baseLetters = lastSame ? (+lastSame.letters||0) : null;
    const todayParcels = todaysRow? (+todaysRow.parcels||0): null;
    const todayLetters = todaysRow? (+todaysRow.letters||0): null;
    const dayPct=(val,base)=> (val==null || !base)? null : ((val-base)/base)*100;
    const tdp=dayPct(todayParcels, baseParcels), tdl=dayPct(todayLetters, baseLetters);
    const wkNames=['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
    document.querySelector('#todayParcelsDelta')?.closest('.stat')?.querySelector('small.muted')?.replaceChildren(document.createTextNode(`vs last ${wkNames[dow]} (worked)`));
    document.querySelector('#todayLettersDelta')?.closest('.stat')?.querySelector('small.muted')?.replaceChildren(document.createTextNode(`vs last ${wkNames[dow]} (worked)`));
    document.querySelector('#todayOfficeDelta')?.closest('.stat')?.querySelector('small.muted')?.replaceChildren(document.createTextNode(`vs last ${wkNames[dow]} (worked)`));
    const baseOffice = lastSame ? (+lastSame.office_minutes||0) : null;
    const todayOffice = todaysRow ? (+todaysRow.office_minutes||0) : null;
    const fmtTiny=p=> p==null? '—' : (p>=0? `↑ ${p.toFixed(0)}%` : `↓ ${Math.abs(p).toFixed(0)}%`);
    const tdo=dayPct(todayOffice, baseOffice);
    $('todayParcelsDelta').textContent = fmtTiny(tdp);
    $('todayLettersDelta').textContent = fmtTiny(tdl);
    $('todayOfficeDelta').textContent = fmtTiny(tdo);
    // Minimal color-only styling for today's deltas
    (() => {
      const tp = document.getElementById('todayParcelsDelta');
      const tl = document.getElementById('todayLettersDelta');
      const to = document.getElementById('todayOfficeDelta');
      const { fg:fgP } = colorForDelta(tdp);
      const { fg:fgL } = colorForDelta(tdl);
      const { fg:fgO } = colorForDelta(tdo);
      if (tp) { tp.className='pill statDelta'; tp.style.color=fgP; tp.style.background='transparent'; tp.style.borderColor='transparent'; }
      if (tl) { tl.className='pill statDelta'; tl.style.color=fgL; tl.style.background='transparent'; tl.style.borderColor='transparent'; }
      if (to) { to.className='pill statDelta'; to.style.color=fgO; to.style.background='transparent'; to.style.borderColor='transparent'; }
    })();
}

  try{
    sb.channel('entries-feed').on('postgres_changes',{event:'*',schema:'public',table:'entries'}, async ()=>{
      const rows = await fetchEntries();
      allRows = rows;
      rebuildAll();
    }).subscribe();
  }catch(e){ console.warn('Realtime not enabled:', e?.message||e); }

  $('fab').addEventListener('click',()=>{ window.scrollTo({ top:0, behavior:'smooth' }); $('departTime').focus(); });
  $('searchBox').addEventListener('input', ()=>{ renderTable(applySearch(allRows)); });

  (function enableRowNavigation(){
    const tbody=document.querySelector('#tbl tbody'); if(!tbody) return; function activate(e){ const tr=e.target.closest('tr.rowLink'); if(!tr) return; $('date').value=tr.dataset.date; loadByDate(); window.scrollTo({ top:0, behavior:'smooth' }); }
    tbody.addEventListener('click', activate);
    tbody.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ if(e.target.closest('tr.rowLink')){ e.preventDefault(); activate(e); } } });
  })();

  // Collapsed UI scaffolding (experimental): add toggle buttons to collapse sections
  function applyCollapsedUi(){
    const enabled = !!(FLAGS && FLAGS.collapsedUi);
    const targets = [
      { id:'addEntryCard' },
      { id:'dowCard' },
      { id:'parcelsOverTimeCard' },
      { id:'lettersOverTimeCard' },
      { id:'monthlyGlanceCard' },
      { id:'quickFilterCard' },
      { id:'dayCompareCard' },
      { id:'recentEntriesCard' },
    ];
    const storeKey = (id)=> `routeStats.collapse.${id}`;
    const $body = (id)=> document.querySelector('#'+id+' > .__collapseBody');
    const $btn  = (id)=> document.querySelector('#'+id+' .__collapseToggle');

    function setSectionCollapsed(id, collapsed){
      const body = $body(id);
      const btn = $btn(id);
      if (body) body.style.display = collapsed ? 'none' : '';
      if (btn){
        btn.textContent = collapsed ? 'Expand' : 'Collapse';
        btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
        const ctrl = btn.getAttribute('aria-controls');
        if (!ctrl && body && body.id) btn.setAttribute('aria-controls', body.id);
      }
      try{ localStorage.setItem(storeKey(id), collapsed ? '1' : '0'); }catch(_){ }
      if (id==='addEntryCard') updateQuickEntryVisibility(collapsed);
    }

    for (const t of targets){
      const sec = document.getElementById(t.id);
      if (!sec) continue;
      // Ensure a header element to host the toggle
      const headerEl = sec.firstElementChild; // usually h3 or header row
      if (!headerEl) continue;
      // Ensure a body wrapper containing all non-header children for reliable show/hide
      let body = sec.querySelector(':scope > .__collapseBody');
      if (!body){
        body = document.createElement('div');
        body.className = '__collapseBody';
        // Move all non-header children into body
        const toMove = [];
        for (let i = 1; i < sec.children.length; i++) toMove.push(sec.children[i]);
        toMove.forEach(node => body.appendChild(node));
        // Assign a unique id for aria-controls linkage
        try{ if (!body.id) body.id = `__cb_${t.id}`; }catch(_){ }
        sec.appendChild(body);
      }
      // Cleanup any stray toggles created previously in the wrong place
      try{
        const toggles = sec.querySelectorAll('.__collapseToggle');
        if (toggles && toggles.length > 1){
          toggles.forEach((b, idx)=>{ if (!headerEl.contains(b) || idx>0) b.remove(); });
        }
      }catch(_){ /* ignore */ }
      // Find or create toggle button (inside header only)
      let btn = headerEl.querySelector('.__collapseToggle');
      if (!btn){
        btn = document.createElement('button');
        btn.className = 'ghost __collapseToggle';
        btn.type = 'button';
        btn.style.marginLeft = 'auto';
        btn.style.float = 'right';
        btn.style.fontSize = '12px';
        btn.textContent = 'Collapse';
        btn.setAttribute('aria-expanded', 'true');
        if (body && body.id) btn.setAttribute('aria-controls', body.id);
        // Append to header (h3 or row)
        try{ headerEl.appendChild(btn); }catch(_){ sec.insertBefore(btn, sec.firstChild); }
      }
      // Handler
      const setCollapsed = (collapsed)=> setSectionCollapsed(t.id, collapsed);
      const saved = (localStorage.getItem(storeKey(t.id)) === '1');
      // Enable/disable per flag
      btn.style.display = enabled ? 'none' : 'none'; // hide explicit button; use header click instead
      if (!enabled){
        // Ensure everything is visible in normal mode
        setCollapsed(false);
        continue;
      }
      // Default: collapse Add Entry and Recent Entries the first time when feature enabled
      if ((t.id==='addEntryCard' || t.id==='recentEntriesCard') && localStorage.getItem(storeKey(t.id)) == null){
        try{ localStorage.setItem(storeKey(t.id), '1'); }catch(_){ }
      }
      const initialCollapsed = (localStorage.getItem(storeKey(t.id)) === '1');
      setCollapsed(initialCollapsed);
      // Header click toggles collapse (ignore clicks on interactive controls inside header)
      const headerToggle = (ev)=>{
        const trg = ev.target;
        if (trg.closest && (trg.closest('#quickEntryBar') || trg.closest('button') || trg.closest('input') || trg.closest('a'))) return;
        const bodyNow = $body(t.id);
        const nowCollapsed = bodyNow && bodyNow.style.display !== 'none' ? true : false;
        setCollapsed(nowCollapsed);
      };
      headerEl.style.cursor = 'pointer';
      headerEl.title = 'Click to expand/collapse';
      headerEl.addEventListener('click', headerToggle);
      headerEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); headerToggle(e); } });
      if (t.id==='addEntryCard') ensureQuickEntryControls(headerEl);
    }
    // removed global Collapse All in favor of Focus Mode
    // expose helpers for Focus Mode
  window.__collapse_targets = targets.map(t=> t.id);
  window.__collapse_set = setSectionCollapsed;
}

  // Focus Mode: collapse everything except snapshot tiles
  function applyFocusMode(){
    try{
      const btn = document.getElementById('btnFocusMode');
      const enabled = !!(FLAGS && FLAGS.collapsedUi);
      if (!btn) return;
      if (!enabled){ btn.style.display='none'; return; }
      btn.style.display='';
      const on = !!(FLAGS && FLAGS.focusMode);
      btn.textContent = `Focus Mode: ${on?'On':'Off'}`;
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      btn.onclick = ()=>{
        FLAGS.focusMode = !FLAGS.focusMode; saveFlags(FLAGS);
        applyFocusMode();
      };
      const targets = window.__collapse_targets || [];
      if (!targets.length) return;
      if (on){
        targets.forEach(id=>{
          if (id==='snapshotCard') return;
          try{ (window.__collapse_set||(()=>{}))(id, true); }catch(_){ }
        });
      } else {
        // Leave sections as-is when Focus Mode is off to preserve user + default collapsed states
      }
    }catch(_){ /* no-op */ }
  }

  // Quick Entry (experimental): show Hit Street / Return buttons when Add Entry is collapsed
  function ensureQuickEntryControls(headerEl){
    if (!FLAGS.quickEntry) return;
    let bar = document.getElementById('quickEntryBar');
    if (!bar){
      bar = document.createElement('span');
      bar.id = 'quickEntryBar';
      bar.style.cssText = 'float:right; display:none; gap:8px; align-items:center; font-size:12px';
      bar.className = 'row';
      const hitBtn = document.createElement('button'); hitBtn.id='quickHitBtn'; hitBtn.className='ghost btn-compact'; hitBtn.type='button'; hitBtn.textContent='Hit Street (now)';
      const retBtn = document.createElement('button'); retBtn.id='quickReturnBtn'; retBtn.className='ghost btn-compact'; retBtn.type='button'; retBtn.textContent='Return (now)';
      bar.appendChild(hitBtn); bar.appendChild(retBtn);
      try{ headerEl.appendChild(bar); }catch(_){ /* no-op */ }
      hitBtn.onclick = ()=>{ try{ $('departTime').value = hhmmNow(); computeBreakdown(); }catch(_){ } };
      retBtn.onclick = ()=>{ try{ $('returnTime').value = hhmmNow(); computeBreakdown(); }catch(_){ } };
    }
    updateQuickEntryVisibility(localStorage.getItem('routeStats.collapse.addEntryCard') === '1');
  }
  function updateQuickEntryVisibility(isCollapsed){
    const bar = document.getElementById('quickEntryBar');
    if (!bar){ return; }
    const show = !!FLAGS.quickEntry && !!isCollapsed;
    bar.style.display = show ? 'inline-flex' : 'none';
  }

  (function bindVolumeLeaderboard(){
    const openBtn = document.getElementById('openVolumeLeaderboard');
    const closeBtn = document.getElementById('closeVolumeLeaderboard');
    const panel = document.getElementById('volumeLeaderboard');
    const showPanel = ()=>{
      if (!panel) return;
      buildVolumeLeaderboard(window.__rawRows || allRows || []);
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior:'smooth', block:'nearest' });
    };
    openBtn?.addEventListener('click', showPanel);
    openBtn?.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); showPanel(); } });
    closeBtn?.addEventListener('click', ()=>{ if(panel) panel.style.display='none'; });
  })();

  // Toggle Weekly details panels (hours, parcels, letters)
  (function enableWeeklyPanels(){
    const panels = ['wkHoursDetails','wkParcelsDetails','wkLettersDetails','advHoursDetails','advParcelsDetails','advLettersDetails'];
    function hideOthers(except){ panels.forEach(id => { if(id!==except){ const el=document.getElementById(id); if(el) el.style.display='none'; } }); }
    function enable(tileId, panelId, closeId){
      const tile=document.getElementById(tileId);
      const panel=document.getElementById(panelId);
      const close=document.getElementById(closeId);
      const toggle=()=>{
        if(!panel) return;
        const show = panel.style.display==='none';
        if(show){ hideOthers(panelId); panel.style.display='block'; panel.scrollIntoView({behavior:'smooth', block:'nearest'}); }
        else { panel.style.display='none'; }
      };
      tile?.addEventListener('click', toggle);
      tile?.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); toggle(); } });
      close?.addEventListener('click', ()=>{ if(panel) panel.style.display='none'; });
    }
    enable('tileWkHours','wkHoursDetails','closeWkHoursDetails');
    enable('tileWkParcels','wkParcelsDetails','closeWkParcelsDetails');
    enable('tileWkLetters','wkLettersDetails','closeWkLettersDetails');
    enable('tileAdvHours','advHoursDetails','closeAdvHoursDetails');
    enable('tileAdvParcels','advParcelsDetails','closeAdvParcelsDetails');
    enable('tileAdvLetters','advLettersDetails','closeAdvLettersDetails');
  })();

  (async()=>{
    $('date').value = todayStr();
    await loadByDate();

    const sessionFromCallback = await authReadyPromise.catch(()=>null);
    const session = sessionFromCallback || await sb.auth.getSession().then(r=> r.data.session).catch(()=>null);
    let rows = [];
    if (session) {
      try {
        rows = await fetchEntries();
      } catch (err) {
        console.warn('Initial fetchEntries failed:', err);
        rows = [];
      }
    }

    allRows = rows;
    window.allRows = rows;
    rebuildAll();
    computeBreakdown();
    applyTrendPillsVisibility();
    applyCollapsedUi();
    applyRecentEntriesAutoCollapse();
    applyFocusMode();
  })();

  console.log('Route Stats loaded —', VERSION_TAG);

  // Developer helper: log diagnostics to the console on demand
  window.showDiagnostics = function(){
    try{
      if (typeof fitVolumeTimeModel !== 'function'){ console.log('Model not loaded'); return; }
      const rows = rowsForModelScope((window.allRows||[])
        .filter(r=> r && r.status!=='off' && ((+r.parcels||0)+(+r.letters||0)>0))
        .sort((a,b)=> a.work_date < b.work_date ? -1 : 1));
      const m = fitVolumeTimeModel(rows);
      if (!m){ console.log('Not enough data for diagnostics'); return; }
      console.table(m.residuals
        .map(d=>({
          date:d.iso,
          parcels:d.parcels,
          letters:d.letters,
          routeH:(d.routeMin/60).toFixed(2),
          predH:(d.predMin/60).toFixed(2),
          residMin:+d.residMin.toFixed(0)
        }))
        .sort((a,b)=> Math.abs(b.residMin) - Math.abs(a.residMin))
        .slice(0,5));
      console.log('bp=', m.bp.toFixed(2), 'bl=', m.bl.toFixed(3), 'w=', (m.bl/m.bp).toFixed(2), 'R^2=', (Math.max(0, Math.min(1, m.r2))*100).toFixed(0)+'%');
      return m;
    }catch(err){ console.warn('showDiagnostics error', err); return null; }
  };
</script>
<!-- Register the service worker for offline support -->
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('sw.js').catch(function(err) {
        console.error('Service worker registration failed:', err);
      });
    });
  }

  // Monthly Glance (preview): compute last 4 weeks totals and show as text when enabled
  function buildMonthlyGlance(rows){
    rows = filterRowsForView(rows||[]);
    const card = document.getElementById('monthlyGlanceCard');
    if (!card) return;
    // Always render Monthly Glance card; flag only controls charts below
    card.style.display='block';
    const today = DateTime.now().setZone(ZONE);
    const weekStart0 = startOfWeekMonday(today);
    const weekEnd0   = today.endOf('day');
    const weekStart1 = startOfWeekMonday(today.minus({weeks:1}));
    const weekEnd1   = endOfWeekSunday(today.minus({weeks:1}));
    const weekStart2 = startOfWeekMonday(today.minus({weeks:2}));
    const weekEnd2   = endOfWeekSunday(today.minus({weeks:2}));
    const weekStart3 = startOfWeekMonday(today.minus({weeks:3}));
    const weekEnd3   = endOfWeekSunday(today.minus({weeks:3}));

    const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
    const worked = rows.filter(r=> r.status!=='off');

    function totals(from,to){
      const arr = worked.filter(r=> inRange(r,from,to));
      const h = arr.reduce((t,r)=> t + (+r.hours||0), 0);
      const p = arr.reduce((t,r)=> t + (+r.parcels||0), 0);
      const l = arr.reduce((t,r)=> t + (+r.letters||0), 0);
      return {h,p,l};
    }
    const W3 = totals(weekStart3, weekEnd3);
    const W2 = totals(weekStart2, weekEnd2);
    const W1 = totals(weekStart1, weekEnd1);
    const W0 = totals(weekStart0, weekEnd0);

    const fmtH = n => (n||0).toFixed(1);
    const labels = [weekEnd3, weekEnd2, weekEnd1, weekEnd0].map(d=> d.toFormat('LLL dd'));

    // Always set text fallback first
    const hoursDiv   = document.getElementById('mgHours');
    const parcelsDiv = document.getElementById('mgParcels');
    const lettersDiv = document.getElementById('mgLetters');
    // Label most recent as W1 (no week zero), older as W2..W4
    hoursDiv.textContent   = `W4 ${fmtH(W3.h)} • W3 ${fmtH(W2.h)} • W2 ${fmtH(W1.h)} • W1 ${fmtH(W0.h)}`;
    parcelsDiv.textContent = `W4 ${W3.p} • W3 ${W2.p} • W2 ${W1.p} • W1 ${W0.p}`;
    lettersDiv.textContent = `W4 ${W3.l} • W3 ${W2.l} • W2 ${W1.l} • W1 ${W0.l}`;

    // Render sparklines if Chart.js is present
    if (window.Chart){
      try{
        function renderSpark(target, dataArr, color, metricName, starts, ends){
          // Clear target and rebuild with a tiny Avg pill above the canvas
          target.innerHTML = '';
          // Compute simple average of the 4 week values
          const nums = (dataArr||[]).filter(v=> v!=null && isFinite(v));
          const avg = nums.length ? nums.reduce((a,b)=>a+Number(b),0)/nums.length : null;
          const fmtAvg = (v)=>{
            if (v==null) return '—';
            return metricName === 'Hours' ? (Math.round(v*10)/10).toFixed(1)+'h' : String(Math.round(v));
          };
          // Chart wrapper (full width)
          const wrap = document.createElement('div');
          wrap.style.display = 'flex';
          wrap.style.flexDirection = 'column';
          wrap.style.width = '100%';
          // Avg pill (small, above chart, does not steal width)
          const avgEl = document.createElement('span');
          avgEl.className = 'pill';
          avgEl.style.fontSize = '11px';
          avgEl.style.padding = '2px 6px';
          avgEl.style.alignSelf = 'flex-start';
          avgEl.style.marginBottom = '4px';
          avgEl.innerHTML = `<small>Avg</small> <b>${fmtAvg(avg)}</b>`;
          wrap.appendChild(avgEl);
          // Create canvas + labels
          const canvas = document.createElement('canvas');
          canvas.className = 'sparkline';
          try{ canvas.height = 56; }catch(_){}
          canvas.style.height = '56px';
          canvas.style.maxHeight = '56px';
          canvas.style.width = '100%';
          canvas.style.cursor = 'pointer';
          wrap.appendChild(canvas);
          const lbl = document.createElement('div');
          lbl.className = 'sparkline-labels';
          lbl.textContent = labels.join(' • ');
          wrap.appendChild(lbl);
          const summary = document.createElement('div');
          summary.className = 'sparkline-summary';
          summary.textContent = 'Click a dot for details';
          wrap.appendChild(summary);
          target.appendChild(wrap);

          const ctx = canvas.getContext('2d');
          // Create a minimal line chart with points only + subtle line
          const chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels,
              datasets: [{
                label: metricName,
                data: dataArr,
                borderColor: color,
                backgroundColor: color,
                tension: 0.25,
                fill: false,
                borderWidth: 1,
                pointRadius: 3,
                pointHoverRadius: 6,
                pointHitRadius: 14,
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              layout: {
                // Extra breathing room so end dots/labels do not clip
                padding: { top: 14, right: 24, bottom: 12, left: 24 }
              },
              interaction: { mode: 'nearest', intersect: false },
              scales: {
                x: { display: false },
                y: { display: false }
              },
              plugins: {
                legend: { display: false },
                tooltip: {
                  enabled: true,
                  callbacks: {
                    title: (items)=> {
                      try{ return fmtRange(items[0].dataIndex); }catch(_){ return ''; }
                    },
                    label: (item)=> {
                      const v = item.parsed.y;
                      if (metricName === 'Hours') return `Hours: ${(+v).toFixed(1)}h`;
                      return `${metricName}: ${Math.round(+v)}`;
                    }
                  }
                }
              },
              elements: {
                point: { pointStyle: 'circle' }
              }
            },
            plugins: []
          });

          function fmtVal(v){
            if (v == null) return '—';
            if (metricName === 'Hours') return (Math.round(v*10)/10).toFixed(1) + 'h';
            return String(Math.round(v));
          }
          function fmtRange(i){
            try{
              const s = starts[i];
              const e = ends[i];
              if (s && e && s.toFormat && e.toFormat){
                return s.toFormat('LLL dd') + ' – ' + e.toFormat('LLL dd');
              }
            }catch(_){ }
            return labels[i] || '';
          }

          // Click: nearest point → show mini summary
          canvas.addEventListener('click', (evt)=>{
            try{
              const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, false);
              if (!points || !points.length) return;
              const idx = points[0].index;
              const msg = `${metricName}: ${fmtVal(dataArr[idx])} · ${fmtRange(idx)}`;
              summary.textContent = msg;
            }catch(_){ /* ignore */ }
          });
          // Keyboard: Enter/Space cycles through points
          canvas.tabIndex = 0;
          canvas.addEventListener('keydown', (e)=>{
            if (e.key !== 'Enter' && e.key !== ' ') return;
            e.preventDefault();
            const cur = (labels.indexOf((summary.textContent||'').split('·').pop()?.trim()) + 1) % dataArr.length;
            const msg = `${metricName}: ${fmtVal(dataArr[cur])} · ${fmtRange(cur)}`;
            summary.textContent = msg;
          });
        }
        const starts = [weekStart3, weekStart2, weekStart1, weekStart0];
        const ends   = [weekEnd3,   weekEnd2,   weekEnd1,   weekEnd0];
        renderSpark(hoursDiv,   [W3.h, W2.h, W1.h, W0.h].map(n=> +(n||0).toFixed(1)), getComputedStyle(document.documentElement).getPropertyValue('--good').trim()  || '#7CE38B', 'Hours',   starts, ends);
        renderSpark(parcelsDiv, [W3.p, W2.p, W1.p, W0.p],                        getComputedStyle(document.documentElement).getPropertyValue('--brand').trim() || '#2b7fff', 'Parcels', starts, ends);
        renderSpark(lettersDiv, [W3.l, W2.l, W1.l, W0.l],                        getComputedStyle(document.documentElement).getPropertyValue('--warn').trim()  || '#FFD27A', 'Letters', starts, ends);
      }catch(e){
        console.warn('Monthly Glance charts failed; showing text fallback', e);
      }
    }
    // If Chart.js missing, try to dynamically load the local vendor copy once
    else if (!window.__chartLoadAttempted){
      window.__chartLoadAttempted = true;
      try{
        const script = document.createElement('script');
        script.src = 'vendor/chart.umd.js';
        script.async = true;
        script.onload = ()=>{
          try{
            if (window.Chart){
              // Rebuild all charted views now that Chart.js is available
              try{ buildMonthlyGlance(allRows||rows||[]); }catch(_){}
              try{ buildCharts(allRows||rows||[]); }catch(_){}
              try{ buildMixViz(allRows||rows||[]); }catch(_){}
              try{ buildOfficeCompare(allRows||rows||[]); }catch(_){}
              try{ buildDayCompare(allRows||rows||[]); }catch(_){}
              try{ buildQuickFilter(allRows||rows||[]); }catch(_){}
            }
          }catch(_){ /* ignore */ }
        };
        script.onerror = ()=> console.warn('Failed to load vendor/chart.umd.js; keeping text fallback');
        document.head.appendChild(script);
      }catch(e){ console.warn('Error injecting Chart.js script', e); }
    }
  }

  // Headline digest (Wed evening only): soft summary under title
  function buildHeadlineDigest(rows){
    rows = filterRowsForView(rows||[]);
    try{
      const el = document.getElementById('headlineDigest'); if(!el) return;
      const now = DateTime.now().setZone(ZONE);
      const isWed = (now.weekday === 3); // Mon=1..Sun=7
      const isEvening = now.hour >= 17; // 5pm local
      const show = !!FLAGS.headlineDigest && isWed && isEvening;
      if (!show){ el.style.display='none'; return; }

      // Blended % for Hours (carry-forward toward today's per-day avg)
      const startOfWeek = startOfWeekMonday(now);
      const endToday    = now.endOf('day');
      const prevStart   = startOfWeekMonday(now.minus({weeks:1}));
      const prevEnd     = endOfWeekSunday(now.minus({weeks:1}));
      const priorStart  = startOfWeekMonday(now.minus({weeks:2}));
      const priorEnd    = endOfWeekSunday(now.minus({weeks:2}));
      const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
      const worked = rows.filter(r=> r.status!=='off');
      const thisW = worked.filter(r=> inRange(r,startOfWeek,endToday));
      const lastW = worked.filter(r=> inRange(r,prevStart,prevEnd));
      const priorW= worked.filter(r=> inRange(r,priorStart,priorEnd));
      const daysWorked = arr=> arr.filter(r=> (+r.hours||0)>0).length;
      const dThis=daysWorked(thisW), dLast=daysWorked(lastW), dPrior=daysWorked(priorW);
      const sumH = (arr)=> arr.reduce((t,r)=> t + (+r.hours||0), 0);
      const avgOrNull=(tot,days)=> days? tot/days : null;
      const pct=(a,b)=> (a==null||b==null||b===0)? null : ((a-b)/b)*100;
      const hCarry = pct(avgOrNull(sumH(lastW),dLast), avgOrNull(sumH(priorW),dPrior));
      const hTarget= pct(avgOrNull(sumH(thisW),dThis), avgOrNull(sumH(lastW),dLast));
      const progress=Math.min(1, dThis/5);
      const blended = (hCarry==null && hTarget==null)? null : (hCarry==null? hTarget : hTarget==null? hCarry : (hCarry*(1-progress) + hTarget*progress));
      const val = blended==null? 0 : Math.round(blended);
      let msg;
      if (val <= -15) msg = 'Much lighter than last week.';
      else if (val < -5) msg = 'A bit lighter than last week.';
      else if (val <= 5) msg = 'Similar to last week — average days.';
      else if (val < 15) msg = 'A bit heavier than last week.';
      else msg = 'Much more intense than last week. Deep breath.';
      el.textContent = msg;
      el.style.display='block';
    }catch(_){ /* no-op */ }
  }

  // === Volume weighting via OLS (derive letter weight from data) ===
  // We model: route_minutes_adj = a + b_parcel*parcels + b_letter*letters
  // Then set LETTER_WEIGHT = b_letter / b_parcel (guarded), so
  // Combined volume = parcels + LETTER_WEIGHT * letters

  function __sum(arr, fn){ let s=0; for (const x of arr) s += +fn(x) || 0; return s; }
  function __countPos(arr, fn){ let c=0; for (const x of arr){ const v=+fn(x); if (isFinite(v) && v>0) c++; } return c; }

  function routeAdjustedMinutes(row){
    // mirror routeAdjustedHours(row) but in minutes. If routeAdjustedHours exists, prefer it and convert.
    try{ if (typeof routeAdjustedHours === 'function'){ const h = routeAdjustedHours(row); return isFinite(h) ? h*60 : (+row.route_minutes||0); } }catch(_){ }
    return Math.max(0, (+row.route_minutes||0));
  }

  function computeLetterWeight(rows){
    rows = (rows||[]).filter(r => r && r.status !== 'off');
    // Build sums for normal equations with intercept
    // X = [1, parcels, letters], y = routeAdjustedMinutes
    const n = rows.length;
    if (!n) return loadLetterWeightFallback();
    const Sy  = __sum(rows, r=> routeAdjustedMinutes(r));
    const Sp  = __sum(rows, r=> +r.parcels||0);
    const Sl  = __sum(rows, r=> +r.letters||0);
    const Spp = __sum(rows, r=> { const v=+r.parcels||0; return v*v; });
    const Sll = __sum(rows, r=> { const v=+r.letters||0; return v*v; });
    const Spl = __sum(rows, r=> { const p=+r.parcels||0, l=+r.letters||0; return p*l; });
    const Spy = __sum(rows, r=> { const p=+r.parcels||0; return p*routeAdjustedMinutes(r); });
    const Sly = __sum(rows, r=> { const l=+r.letters||0; return l*routeAdjustedMinutes(r); });

    // Solve 3x3 via block elimination. Center variables to improve stability.
    const mp = Sp/n, ml = Sl/n, my = Sy/n;
    let Cpp=0, Cll=0, Cpl=0, Cpy=0, Cly=0;
    for (const r of rows){
      const p=(+r.parcels||0)-mp, l=(+r.letters||0)-ml, y=routeAdjustedMinutes(r)-my;
      Cpp += p*p; Cll += l*l; Cpl += p*l; Cpy += p*y; Cly += l*y;
    }
    // Solve for [b_p, b_l] in centered system: [Cpp Cpl; Cpl Cll] * [bp bl]^T = [Cpy Cly]^T
    const det = (Cpp*Cll - Cpl*Cpl);
    if (!isFinite(det) || Math.abs(det) < 1e-6){ return loadLetterWeightFallback(); }
    const bp = ( Cpy*Cll - Cpl*Cly ) / det; // minutes per parcel
    const bl = ( Cpp*Cly - Cpl*Cpy ) / det; // minutes per letter

    // Derive weight as ratio (letters impact relative to parcels)
    let w = (isFinite(bp) && Math.abs(bp) > 1e-6) ? (bl / bp) : null;
    // Guardrails: allow 0..1.5 typical; default to saved/fallback if out of range
    if (!isFinite(w) || w < 0) w = 0; if (w > 1.5) w = 1.5;

    // Smooth with previous value to avoid jitter (exponential moving average)
    const prev = loadLetterWeightFallback();
    const alpha = 0.3; // 30% new, 70% previous
    const smoothed = (prev!=null && isFinite(prev)) ? (alpha*w + (1-alpha)*prev) : w;

    try{ localStorage.setItem('routeStats.letterWeight', String(smoothed)); }catch(_){ }
    return smoothed;
  }

  function loadLetterWeightFallback(){
    const DEF = 0.33; // legacy default
    try{ const v = parseFloat(localStorage.getItem('routeStats.letterWeight')); if (isFinite(v) && v>0) return v; }catch(_){ }
    return DEF;
  }

  function getLetterWeight(rows){
    // Use last ~60 worked days for fit to keep it recent
    try{
      const worked = (rows||[]).filter(r=> r && r.status !== 'off' && (+r.parcels||0) + (+r.letters||0) > 0);
      const sorted = worked.slice().sort((a,b)=> (a.work_date < b.work_date ? -1 : 1));
      const sample = sorted.slice(-60);
      return computeLetterWeight(sample);
    }catch(_){ return loadLetterWeightFallback(); }
  }

  function combinedVolume(p, l, w){
    w = (w==null) ? loadLetterWeightFallback() : w;
    const pp = +p||0, ll = +l||0;
    return +(pp + w*ll).toFixed(2);
  }

  // Volume Mix: normalized side-by-side bars (Parcels vs Letters×weight)
  function buildMixViz(rows){
    rows = filterRowsForView(rows||[]);
    const letterW = getLetterWeight(rows);
    const card = document.getElementById('mixVizCard'); if(!card) return;
    if (!FLAGS.mixViz) { card.style.display='none'; return; }
    // Show card early so header is visible even if later logic fails
    card.style.display='block';
    const text = document.getElementById('mixText');
    const eff  = document.getElementById('mixEff');
    const overlay = document.getElementById('weekOverlay');
    const culprits = document.getElementById('mixCulprits');
    const details = document.getElementById('mixCompareDetails');
    const btn = document.getElementById('mixCompareBtn');
    const now = DateTime.now().setZone(ZONE);
    const startThis = startOfWeekMonday(now);
    const endThis   = now.endOf('day');
    const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
    const worked = rows.filter(r=> r.status!=='off');
    const baseWeek = getLastNonEmptyWeek(worked, now, { excludeVacation: true });
    const startLast = baseWeek.start;
    const endLastFull = baseWeek.end;
    const lastEndSame = luxon.DateTime.min(
      endLastFull,
      baseWeek.start.plus({ days: Math.max(0, now.weekday - 1) }).endOf('day')
    );
    const W0 = worked.filter(r=> inRange(r,startThis,endThis));
    const W1 = baseWeek.rows.filter(r=> inRange(r,startLast,lastEndSame));
    const dayIdxToday = (now.weekday + 6) % 7;
    const sum = (arr,fn)=> arr.reduce((t,x)=> t + (fn(x)||0), 0);
    const p0=sum(W0,r=>+r.parcels||0), p1=sum(W1,r=>+r.parcels||0);
    const l0=sum(W0,r=>+r.letters||0), l1=sum(W1,r=>+r.letters||0);
    const ln0 = +( (letterW * l0) ).toFixed(1);
    const ln1 = +( (letterW * l1) ).toFixed(1);
    try{
      // Labeling: W1 = current (Mon..today), W2 = last (same range)
      if (text) text.textContent = `W1: Parcels ${p0}, Letters ${l0} • W2: Parcels ${p1}, Letters ${l1}`;
      const wBadge = document.getElementById('mixWeight');
    if (wBadge){ wBadge.style.display='inline-flex'; wBadge.innerHTML = `<small class="modelMetric">Letter w</small> <span>${(Math.round(letterW*100)/100).toFixed(2)}</span>`; }
    const vol0 = combinedVolume(p0, l0, letterW); const vol1 = combinedVolume(p1, l1, letterW);
    const rm0  = sum(W0,r=> routeAdjustedHours(r));
    const rm1  = sum(W1,r=> routeAdjustedHours(r));
    const idx0 = (vol0>0 && rm0>0) ? (rm0/vol0) : null;
    const idx1 = (vol1>0 && rm1>0) ? (rm1/vol1) : null;
    let deltaStr = '—', deltaStyle='';
    if (idx0!=null && idx1!=null && idx1>0){
      const imp = ((idx1 - idx0) / idx1) * 100;
      const s = Math.round(imp);
      const fg = (imp >= 0) ? 'var(--good)' : 'var(--bad)';
      deltaStr = `${s>=0?'↑':'↓'} ${Math.abs(s)}%`;
      deltaStyle = `color:${fg}`;
    }
    if (eff){
      const a = idx0==null? '—' : (Math.round(idx0*100)/100).toFixed(2);
      const b = idx1==null? '—' : (Math.round(idx1*100)/100).toFixed(2);
      eff.innerHTML = `Efficiency index (min/vol): ${a} vs ${b} <span style="${deltaStyle}">${deltaStr}</span>`;
    }
    // Outlier days: route hours vs last week (same weekday) > +10%
    try{
      if (culprits){
        const days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
        const routeByDow = (arr)=>{
          const a = Array.from({length:7},()=>0);
          arr.forEach(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; a[idx]+= routeAdjustedHours(r); });
          return a;
        };
        const thisRoute = routeByDow(W0);
        const lastRoute = routeByDow(baseWeek.rows);
        const out = [];
        for (let i=0;i<=dayIdxToday && i<7;i++){
          const base = lastRoute[i]||0, cur = thisRoute[i]||0;
          if (base>0){ const d = Math.round(((cur-base)/base)*100); if (d>=10){
            // Try to find a reason tag for the day
            const dayIso = W0.find(r=> (DateTime.fromISO(r.work_date,{zone:ZONE}).weekday+6)%7===i)?.weather_json || '';
            let reason=''; try{ const m=/Reason:\s*([^·]+)/i.exec(dayIso); if(m) reason=m[1].trim(); }catch(_){ }
            out.push(`${days[i]} (+${d}%)${reason? ' — '+reason:''}`);
          } }
        }
        culprits.textContent = out.length ? ('Outliers: ' + out.join(' • ')) : 'Outliers: —';
      }
    }catch(_){ /* ignore */ }
    const d = (a,b)=> (b>0)? Math.round(((a-b)/b)*100) : null;
    const dH = d(sum(W0,r=>+r.hours||0), sum(W1,r=>+r.hours||0));
    let dP, dLx, lineLabelP='Parcels', lineLabelL='Letters';
    // Ensure scoped defaults so details rendering doesn't break when baselineCompare is off
    let resP = { used: 0 };
    let resL = { used: 0 };
    const baselines = ensureWeeklyBaselines(rows) || getWeeklyBaselines();
    const anchor = computeAnchorBaselines(rows, 8);
    if (FLAGS.baselineCompare){
      // Baseline-normalized: compare this week's Mon..today vs weekday baselines from previous 2 weeks
      const dayIdxToday = (now.weekday + 6) % 7; // Mon=0..Sun=6
      const mins = 5; // guardrail: require baseline >= 5 units per weekday
      // Helpers
      const sumRange = (arr, upto)=>{ let s=0; for(let i=0;i<=upto;i++){ const v=arr[i]; s+= (v!=null? v:0); } return s; };
      const byW = (arr,fn)=>{
        const out = Array.from({length:7},()=>0);
        arr.forEach(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; out[idx] += (fn(r)||0); });
        return out;
      };
      const alignedDelta = (curArr, baseArr, upto, min)=>{
        let curSum=0, baseSum=0, used=0;
        for (let i=0;i<=upto;i++){
          const base = baseArr ? baseArr[i] : null;
          if (base!=null && base>=min){
            curSum += (curArr[i]||0);
            baseSum += base;
            used++;
          }
        }
        if (!used || baseSum<=0) return { delta:null, used:0 };
        let d = Math.round(((curSum - baseSum)/baseSum)*100);
        if (d>100) d=100; if (d<-100) d=-100;
        return { delta:d, used };
      };
      const pThisW = byW(W0, r=> +r.parcels||0);
      const lThisW = byW(W0, r=> +r.letters||0);
      const bp = baselines ? baselines.parcels : null;
      const bl = baselines ? baselines.letters : null;
      resP = alignedDelta(pThisW, bp, dayIdxToday, mins);
      resL = alignedDelta(lThisW, bl, dayIdxToday, mins);
      dP = resP.delta;
      dLx= resL.delta;
      lineLabelP = 'Parcels (vs baseline)';
      lineLabelL = 'Letters (vs baseline)';
      // Anchor drift (optional, show as part of details header)
      let driftLine = '';
      if (anchor && anchor.parcels && anchor.letters){
        const ap = sumRange(anchor.parcels, dayIdxToday);
        const al = sumRange(anchor.letters, dayIdxToday);
        // aligned baseline sums over weekdays we have baselines for
        const sumAligned=(arr,upto,min)=>{ let s=0; let used=0; for(let i=0;i<=upto;i++){ const v=arr?arr[i]:null; if (v!=null && v>=min){ s+=v; used++; } } return used? s: null; };
        const bpAligned = sumAligned(bp, dayIdxToday, mins);
        const blAligned = sumAligned(bl, dayIdxToday, mins);
        const driftP = (ap>0 && bpAligned!=null)? Math.round(((bpAligned - ap)/ap)*100) : null;
        const driftL = (al>0 && blAligned!=null)? Math.round(((blAligned - al)/al)*100) : null;
        driftLine = `Baseline drift vs anchor — Parcels: ${driftP==null?'—':(driftP>=0?('↑ '+driftP+'%'):('↓ '+Math.abs(driftP)+'%'))} • Letters: ${driftL==null?'—':(driftL>=0?('↑ '+driftL+'%'):('↓ '+Math.abs(driftL)+'%'))}`;
        // Prepend drift line on first render
        if (details && !details._driftInjected){
          const div=document.createElement('div'); div.className='sparkline-labels'; div.textContent=driftLine; details.parentNode.insertBefore(div, details);
          details._driftInjected = true;
        }
      }
    } else {
      // Simple week-over-week (Mon..today vs last Mon..today)
      dP = d(p0,p1);
      dLx= d(l0,l1);
    }
    const expectationStroke = 'rgba(255,140,0,0.85)';
    const expectationFill = 'rgba(255,140,0,0.22)';
    const dEff = ( (p0+ln0)>0 && (p1+ln1)>0 )
      ? Math.round((( (rm1/(p1+ln1)) - (rm0/(p0+ln0)) ) / (rm1/(p1+ln1)) )*100)
      : null;
    const arrow=(v)=> v==null?'—':(v>=0?'↑ '+v+'%':'↓ '+Math.abs(v)+'%');
    const color=(v)=> v==null?'var(--text)':(v>=0?'var(--good)':'var(--bad)');
    const line=(label,v,ctx,colorOverride)=>{
      const labelHtml = colorOverride ? `<span style="color:${colorOverride};font-weight:600">${label}</span>` : label;
      return `<div>${labelHtml}: <span style="color:${color(v)}">${arrow(v)}</span> ${ctx||''}</div>`;
    };
    if (details){
      const usedP = (typeof resP!== 'undefined' && resP && resP.used) ? `, ${resP.used} day(s) used` : '';
      const usedL = (typeof resL!== 'undefined' && resL && resL.used) ? `, ${resL.used} day(s) used` : '';
      details.innerHTML = [
        line('Efficiency', dEff, `(min/vol ${ ( (rm0/(p0+ln0))||0 ).toFixed(2) } vs ${ ( (rm1/(p1+ln1))||0 ).toFixed(2) })`),
        line(lineLabelP, dP, `(${p0} vs ${p1}${usedP})`, warn || '#f97316'),
        line(lineLabelL, dLx, `(${l0} vs ${l1}${usedL})`, '#60a5fa'),
        line('Hours', dH, `(${(sum(W0,r=>+r.hours||0)).toFixed(1)}h vs ${(sum(W1,r=>+r.hours||0)).toFixed(1)}h)`)
      ].join('');
    }
    } catch (e) {
      console.error('[MixViz] render error', e);
      if (details) details.innerHTML = '<div>Compare unavailable — data not ready.</div>';
    }
    // Week overlay sparkline (this Mon..today vs last Mon..Sun) + route minutes line
    try{
      if (overlay && window.Chart && overlay.getContext){
        const ctx = overlay.getContext('2d');
        if (overlay._chart) { try{ overlay._chart.destroy(); }catch(_){ } }
        const days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
        const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim()||'#2b7fff';
        const warn  = getComputedStyle(document.documentElement).getPropertyValue('--warn').trim() || '#FFD27A';
        const good  = getComputedStyle(document.documentElement).getPropertyValue('--good').trim() || '#7CE38B';
        // Build daily arrays
        const volByDow = (arr)=>{
          const a = Array.from({length:7},()=>0);
          arr.forEach(r=>{
            const d=DateTime.fromISO(r.work_date,{zone:ZONE});
            const idx=(d.weekday+6)%7;
            a[idx]+= combinedVolume((+r.parcels||0), (+r.letters||0), letterW);
          });
          return a.map(n=> +(Math.round(n*10)/10).toFixed(1));
        };
        const routeByDow = (arr)=>{
          const a = Array.from({length:7},()=>0);
          arr.forEach(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; a[idx]+= Math.max(0, (+r.route_minutes||0) - boxholderAdjMinutes(r)); });
          return a.map(n=> +(Math.round(n*100)/100).toFixed(2));
        };
        const thisBy = volByDow(W0);
        // Baseline uses LAST FULL WEEK (Mon..Sun) so the blue line is complete
        const W1full = baseWeek.rows;
        const lastBy = volByDow(W1full);
        const thisRoute = routeByDow(W0);
        const lastRoute = routeByDow(W1full);
        const dayIdxToday = (now.weekday + 6) % 7;
        const hasBand = !!(bandMinData && bandMaxData);
        const isoForPoint = (datasetIndex, idx) => {
          try{
            if (hasBand){
              if (datasetIndex === 0 || datasetIndex === 1) return startThis.plus({ days: idx }).toISODate();
              if (datasetIndex === 2) return startLast.plus({ days: idx }).toISODate();
              if (datasetIndex === 3 || datasetIndex === 4) return startThis.plus({ days: idx }).toISODate();
            }else{
              if (datasetIndex === 0) return startLast.plus({ days: idx }).toISODate();
              if (datasetIndex === 1 || datasetIndex === 2) return startThis.plus({ days: idx }).toISODate();
            }
          }catch(_){ /* ignore */ }
          return null;
        };
        const thisMasked = thisBy.map((v,i)=> i<=dayIdxToday? v : null);
        const thisRouteMasked = thisRoute.map((v,i)=> i<=dayIdxToday? v : null);
        const datasets = [];
        if (bandMinData && bandMaxData){
          datasets.push({
            label:'Vol expect min',
            data:bandMinData,
            borderColor:expectationStroke,
            borderWidth:1,
            borderDash:[6,4],
            backgroundColor:'transparent',
            pointRadius:0,
            spanGaps:true,
            fill:false
          });
          datasets.push({
            label:'Vol expect max',
            data:bandMaxData,
            borderColor:'rgba(0,0,0,0)',
            backgroundColor:expectationFill,
            pointRadius:0,
            borderWidth:0,
            spanGaps:true,
            fill:{ target:'-1', above:expectationFill, below:expectationFill }
          });
        }
        datasets.push(
          { label:'Vol last', data:lastBy, borderColor:brand, backgroundColor:'transparent', tension:0.25, pointRadius:3, pointHoverRadius:6, pointHitRadius:14, borderWidth:2, spanGaps:true, yAxisID:'y' },
          { label:'Vol this', data:thisMasked, borderColor:warn,  backgroundColor:'transparent', tension:0.25, pointRadius:3, pointHoverRadius:6, pointHitRadius:14, borderWidth:2, spanGaps:true, yAxisID:'y' },
          { label:'Route h (this)', data:thisRouteMasked, borderColor:good, backgroundColor:'transparent', borderDash:[4,3], tension:0.25, pointRadius:2, pointHoverRadius:5, pointHitRadius:12, borderWidth:2, spanGaps:true, yAxisID:'y2' }
        );
        overlay._chart = new Chart(ctx, {
          type:'line',
          data:{ labels:days, datasets },
          options:{ responsive:true, maintainAspectRatio:false,
            layout:{ padding:{ top:12, right:16, bottom:10, left:16 } },
            interaction:{ mode:'nearest', intersect:false },
            plugins:{ legend:{ display:false }, tooltip:{
              callbacks:{
                title:(items)=>{
                  if (!items || !items.length) return '';
                  const item = items[0];
                  const iso = isoForPoint(item.datasetIndex, item.dataIndex);
                  if (iso){
                    const dt = DateTime.fromISO(iso, { zone: ZONE });
                    return dt.toFormat('ccc • MMM d, yyyy') + vacGlyph(iso);
                  }
                  const lbl = item.label || '';
                  return lbl + vacGlyph(lbl);
                },
                label:(item)=>{
                  const i=item.dataIndex; const lw=lastBy[i]; const tw=thisBy[i];
                  const hasTw = i<=dayIdxToday && tw!=null;
                  if (item.dataset?.label === 'Vol expect min') return '';
                  if (item.dataset?.label === 'Vol expect max'){
                    const min = bandMinData?.[i];
                    const max = bandMaxData?.[i];
                    const fmt = (n)=> n==null? '—' : n.toFixed(1);
                    return `Expectation: ${fmt(min)} – ${fmt(max)}`;
                  }
                  if (item.dataset?.label === 'Route h (this)'){
                    const rw=thisRoute[i]; const rl=lastRoute[i]; const fmt=(n)=> n==null?'—':(Math.round(n*100)/100).toFixed(2);
                    return hasTw? `This route: ${fmt(rw)}h (Last: ${fmt(rl)}h)` : `Last route: ${fmt(rl)}h`;
                  }
                  return hasTw? `This vol: ${tw} (Last: ${lw})` : `Last vol: ${lw}`;
                }
              }
            }},
            scales:{ x:{ display:true, grid:{ display:false } }, y:{ display:false }, y2:{ display:false, position:'right' } }
          }
        });
      }
    }catch(_){ /* no-op */ }
    // Efficiency overlay sparkline (min/vol): last full week vs this Mon..today
    try{
      const effCanvas = document.getElementById('effOverlay');
      if (effCanvas && window.Chart && effCanvas.getContext){
        const ctx = effCanvas.getContext('2d');
        if (effCanvas._chart) { try{ effCanvas._chart.destroy(); }catch(_){ } }
        const days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
        const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim()||'#2b7fff';
        const warn  = getComputedStyle(document.documentElement).getPropertyValue('--warn').trim() || '#FFD27A';
        const routeByDow = (arr)=>{
          const a = Array.from({length:7},()=>0);
          arr.forEach(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; a[idx]+= Math.max(0, (+r.route_minutes||0) - boxholderAdjMinutes(r)); });
          return a.map(n=> +(Math.round(n*100)/100).toFixed(2));
        };
        const volByDow = (arr)=>{
          const a = Array.from({length:7},()=>0);
          arr.forEach(r=>{
            const d=DateTime.fromISO(r.work_date,{zone:ZONE});
            const idx=(d.weekday+6)%7;
            a[idx]+= combinedVolume((+r.parcels||0), (+r.letters||0), letterW);
          });
          return a.map(n=> +(Math.round(n*10)/10).toFixed(1));
        };
        const thisRoute = routeByDow(W0);
        const thisVol   = volByDow(W0);
        const lastRoute = routeByDow(W1full);
        const lastVol   = volByDow(W1full);
        const eff = (r,v)=> v>0? (r/v) : null;
        const thisEff = thisRoute.map((r,i)=> eff(r, thisVol[i]||0));
        const lastEff = lastRoute.map((r,i)=> eff(r, lastVol[i]||0));
        const dayIdxToday = (now.weekday + 6) % 7;
        const thisMasked = thisEff.map((v,i)=> i<=dayIdxToday? (v!=null? +(Math.round(v*100)/100).toFixed(2) : null) : null);
        const lastVals   = lastEff.map(v=> v!=null? +(Math.round(v*100)/100).toFixed(2) : null);
        effCanvas._chart = new Chart(ctx, {
          type:'line',
          data:{ labels:days, datasets:[
            { label:'Last week', data:lastVals, borderColor:brand, backgroundColor:'transparent', tension:0.25, pointRadius:3, pointHoverRadius:6, pointHitRadius:14, borderWidth:2, spanGaps:true },
            { label:'This week', data:thisMasked, borderColor:warn,  backgroundColor:'transparent', tension:0.25, pointRadius:3, pointHoverRadius:6, pointHitRadius:14, borderWidth:2, spanGaps:true }
          ]},
          options:{ responsive:true, maintainAspectRatio:false,
            layout:{ padding:{ top:8, right:16, bottom:6, left:16 } },
            interaction:{ mode:'nearest', intersect:false },
            plugins:{ legend:{ display:false }, tooltip:{
              callbacks:{
                title:(items)=> items && items[0]? items[0].label : '',
                label:(item)=>{
                  const i=item.dataIndex; const lw=lastVals[i]; const tw=thisEff[i];
                  const hasTw = i<=dayIdxToday && tw!=null;
                  const fmt = (n)=> n==null? '—' : (Math.round(n*100)/100).toFixed(2);
                  return hasTw? `This: ${fmt(tw)} (Last: ${fmt(lw)})` : `Last: ${fmt(lw)}`;
                }
              }
            }},
            scales:{ x:{ display:true, grid:{ display:false } }, y:{ display:false } }
          }
        });
      }
    }catch(_){ /* no-op */ }
    // Baseline drift sparkline (last 8 full weeks, Mon..Sun totals)
    try{
      const driftCanvas = document.getElementById('mixDrift');
      const driftText = document.getElementById('mixDriftText');
      if (driftCanvas && driftText){
        const weeksBack = 5; // use last 5 completed weeks
        const weeksArr=[]; for(let w=weeksBack; w>=1; w--){ const s=startOfWeekMonday(now.minus({weeks:w})); const e=endOfWeekSunday(now.minus({weeks:w})); weeksArr.push({s,e}); }
        const weekSum=(wk,fn)=> worked.filter(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=wk.s && d<=wk.e; }).reduce((t,r)=> t+(fn(r)||0),0);
        const combSer = weeksArr.map(wk=>{
          const p=weekSum(wk, r=>+r.parcels||0); const l=weekSum(wk, r=>+r.letters||0); return +combinedVolume(p, l, letterW).toFixed(1);
        }).filter(v=> v>0);
        // Drift labels: W1 = most recent completed week, W{n} older
        const labels = weeksArr.slice(-combSer.length).map((wk,i)=> `W${combSer.length-i}`);
        // Anchor = median of combined series (non-zero)
        const sorted=[...combSer].sort((a,b)=>a-b); const n=sorted.length; const anchorVal = n? (n%2? sorted[Math.floor(n/2)] : (sorted[n/2-1]+sorted[n/2])/2) : 0;
        driftText.textContent = `Combined vol (P + ${letterW.toFixed(2)}×L): ${combSer.join(', ')} • Anchor: ${anchorVal}`;
        if (window.Chart && driftCanvas.getContext){
          const ctx = driftCanvas.getContext('2d');
          if (driftCanvas._chart) { try{ driftCanvas._chart.destroy(); }catch(_){} }
          const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim()||'#2b7fff';
          const warn  = getComputedStyle(document.documentElement).getPropertyValue('--warn').trim() || '#FFD27A';
          driftCanvas._chart = new Chart(ctx, {
            type:'line',
            data:{ labels, datasets:[
              { label:'Combined', data:combSer, borderColor:warn, backgroundColor:'transparent', tension:0.25, pointRadius:2, borderWidth:1 },
              { label:'Anchor', type:'line', data:combSer.map(()=>anchorVal), borderColor:brand, backgroundColor:'transparent', borderDash:[4,2], pointRadius:0, tension:0 }
            ]},
            options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false }, tooltip:{ enabled:false } }, scales:{ x:{ display:false }, y:{ display:false } } }
          });
        }
      }
    }catch(_){ /* ignore */ }

    // (Historical baseline comparison removed per scope)
    btn?.addEventListener('click', ()=>{
      if (!details) return;
      const show = details.style.display==='none';
      details.style.display = show ? 'block' : 'none';
    });
    // Already shown early; keep behavior consistent
  }

  // Smart Summary (rule-based, text-only): concise 1–2 lines under the title
  function buildSmartSummary(rows){
    rows = filterRowsForView(rows||[]);
    try{
      const el = document.getElementById('smartSummary'); if (!el) return;
      if (!FLAGS.smartSummary) { el.style.display='none'; return; }
      const now = DateTime.now().setZone(ZONE);
      const startThis = startOfWeekMonday(now);
      const endThis   = now.endOf('day');
      const startLast = startOfWeekMonday(now.minus({weeks:1}));
      const lastEndSame = startOfWeekMonday(now.minus({weeks:1})).plus({days: now.weekday-1}).endOf('day');
      const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
    const worked = (rows||[]).filter(r=> r.status!=='off');
    const W0 = worked.filter(r=> inRange(r,startThis,endThis));
    const W1 = worked.filter(r=> inRange(r,startLast,lastEndSame));
    const daysThisWeek = [...new Set(W0.map(r=> r.work_date))].length;
    if (!daysThisWeek){
      el.textContent = 'No worked days yet — 0 day(s) this week.';
      el.style.display = 'block';
      return;
    }
    const sum = (arr,fn)=> arr.reduce((t,x)=> t + (fn(x)||0), 0);
    const h0 = sum(W0, r=> +r.hours||0), h1 = sum(W1, r=> +r.hours||0);
    const p0 = sum(W0, r=> +r.parcels||0), p1 = sum(W1, r=> +r.parcels||0);
      const l0 = sum(W0, r=> +r.letters||0), l1 = sum(W1, r=> +r.letters||0);
      const letterW = getLetterWeight(rows);
      const vol = (p,l)=> p + letterW*l;
      const v0 = vol(p0,l0), v1 = vol(p1,l1);
      const rm0 = sum(W0, r=> routeAdjustedHours(r)),
            rm1 = sum(W1, r=> routeAdjustedHours(r));
      const idx = (rm, vv)=> (rm>0 && vv>0) ? (rm/vv) : null; // minutes per combined volume
      const i0 = idx(rm0, v0), i1 = idx(rm1, v1);
      const pct = (a,b)=> (b>0) ? Math.round(((a-b)/b)*100) : null; // nearest 1%
      const dh = pct(h0, h1);
      const dv = pct(v0, v1);
      const di = (i0!=null && i1!=null && i1>0) ? Math.round(((i1 - i0)/i1)*100) : null; // improvement positive
      const items = [];
      if (dh!=null && Math.abs(dh) >= 5) items.push({ k:'Hours', v:dh });
      if (dv!=null && Math.abs(dv) >= 5) items.push({ k:'Volume', v:dv });
      if (di!=null && Math.abs(di) >= 5) items.push({ k:'Efficiency', v:di });
      // sort by absolute magnitude, descending, and pick top 2 movers
      items.sort((a,b)=> Math.abs(b.v) - Math.abs(a.v));
      const top = items.slice(0,2);
      const parts = top.map(it => `${it.k} ${it.v>=0?`↑ ${it.v}%`:`↓ ${Math.abs(it.v)}%`}`);
      const line = parts.length ? parts.join(' • ') : 'Similar to last week';
      el.textContent = `${line} — ${daysThisWeek} day(s) this week.`;
      el.style.display='block';
    }catch(_){ /* no-op */ }
  }

  // Trending Factors: top two movers this week vs last (Mon..today vs Mon..today).
  function buildTrendingFactors(rows){
    rows = filterRowsForView(rows||[]);
    try{
      const el = document.getElementById('trendFactors'); if(!el) return;
      const now = DateTime.now().setZone(ZONE);
      const startThis = startOfWeekMonday(now);
      const endThis   = now.endOf('day');
      const startLast = startOfWeekMonday(now.minus({weeks:1}));
      const lastEndSame = startOfWeekMonday(now.minus({weeks:1})).plus({days: now.weekday-1}).endOf('day');
      const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
    const worked = (rows||[]).filter(r=> r.status!=='off');
    const W0 = worked.filter(r=> inRange(r,startThis,endThis));
    const W1 = worked.filter(r=> inRange(r,startLast,lastEndSame));
    if (!W0.length){
      el.style.display = 'none';
      return;
    }
    const sum = (arr,fn)=> arr.reduce((t,x)=> t + (fn(x)||0), 0);
    const off0 = sum(W0, r=> +r.office_minutes||0), off1 = sum(W1, r=> +r.office_minutes||0);
    const rm0  = sum(W0, r=> routeAdjustedHours(r));
    const rm1  = sum(W1, r=> routeAdjustedHours(r));
      const vol = (arr)=> sum(arr, r=> (+r.parcels||0) + 0.33*(+r.letters||0));
      const v0 = vol(W0), v1 = vol(W1);
      const pct = (a,b)=> (b>0)? Math.round(((a-b)/b)*100) : null;
      const items = [];
      const pushIf = (k, d)=>{ if (d!=null && Math.abs(d)>=5) items.push({k,v:d}); };
      pushIf('Office', pct(off0, off1));
      pushIf('Route',  pct(rm0, rm1));
      pushIf('Volume', pct(v0, v1));
      items.sort((a,b)=> Math.abs(b.v) - Math.abs(a.v));
      const top = items.slice(0,2);
      if (!top.length){
        el.style.display = 'none';
        el.innerHTML = '';
      } else {
        const pills = top.map(it=> `<span class="pill"><small>${it.k}</small> <b style="color:${colorForDelta(it.v).fg}">${it.v>=0?'↑ '+it.v+'%':'↓ '+Math.abs(it.v)+'%'}</b></span>`).join(' ');
        el.style.display = 'block';
        el.innerHTML = `<small>Weekly Movers</small><div class="pill-row">${pills}</div>`;
      }
    }catch(_){ /* no-op */ }
  }

  // Heaviness (today): attribute total-hours delta into Office vs Route (adjusted).
  function buildHeavinessToday(rows){
    rows = filterRowsForView(rows||[]);
    try{
      const el = document.getElementById('todayHeaviness'); if (!el) return;
      const now = DateTime.now().setZone(ZONE);
      const dow = now.weekday % 7;
      const worked = (rows||[]).filter(r=> r.status!=='off');
      const todayIso = now.toISODate();
      const todayRow = worked.find(r=> r.work_date === todayIso);
      if (!todayRow){ el.style.display='none'; return; }
      const offTodayH = (+todayRow.office_minutes||0);
      const rteTodayH = routeAdjustedHours(todayRow);
      const totTodayH = (+todayRow.hours||0) || (offTodayH + rteTodayH);
      // Baselines by DOW
      const sameDow = worked.filter(r=> r.work_date !== todayIso && (dowIndex(r.work_date)===dow));
      const avg = (arr,fn)=>{ const v = arr.map(fn).filter(x=> x>0); return v.length? (v.reduce((a,b)=>a+b,0)/v.length) : null; };
      const offAvgH = avg(sameDow, r=> (+r.office_minutes||0));
      const rteAvgH = avg(sameDow, r=> routeAdjustedHours(r));
      const totAvgH = avg(sameDow, r=> (+r.hours||0));
      if (offAvgH==null && rteAvgH==null && totAvgH==null){ el.style.display='none'; return; }
      const dOff = (offAvgH==null)? null : (offTodayH - offAvgH);
      const dRte = (rteAvgH==null)? null : (rteTodayH - rteAvgH);
      const dTot = (totAvgH==null)? null : (totTodayH - totAvgH);
      const baseTot = (totAvgH && totAvgH>0)? totAvgH : ((offAvgH||0)+(rteAvgH||0))||null;
      const pct = (x)=> (x==null || !baseTot)? null : Math.round((x/baseTot)*100);
      const pill = (label,dh)=>{
        const p = pct(dh);
        const txt = (dh==null)? '—' : `${dh>=0?'+':''}${(Math.round(dh*10)/10).toFixed(1)}h`;
        const pTxt = (p==null)? '' : ` (${p>=0?'+':''}${p}%)`;
        const col = colorForDelta(p||0).fg;
        return `<span class="pill"><small>${label}</small> <b style="color:${col}">${txt}${pTxt}</b></span>`;
      };
      el.style.display='block';
      const pills = [pill('Office', dOff), pill('Route', dRte), pill('Total', dTot)].join(' ');
      el.innerHTML = `<small>Heaviness (today)</small><div class="pill-row">${pills}</div>`;
    }catch(_){ /* no-op */ }
  }

  // Week Heaviness: attribution Mon..today vs last Mon..today (Office vs Route adjusted vs Total)
  function buildWeekHeaviness(rows){
    rows = filterRowsForView(rows||[]);
    try{
      const el = document.getElementById('weekHeaviness'); if (!el) return;
      const now = DateTime.now().setZone(ZONE);
      const startThis = startOfWeekMonday(now);
      const endThis   = now.endOf('day');
      const startLast = startOfWeekMonday(now.minus({weeks:1}));
      const lastEndSame = startOfWeekMonday(now.minus({weeks:1})).plus({days: now.weekday-1}).endOf('day');
      const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
      const worked = (rows||[]).filter(r=> r.status!=='off');
      const thisWeek = worked.filter(r=> inRange(r,startThis,endThis));
      const lastWeek = worked.filter(r=> inRange(r,startLast,lastEndSame));
      if (!thisWeek.length || !lastWeek.length){ el.style.display='none'; return; }

      const sum = (arr,fn)=> arr.reduce((t,x)=> t + (fn(x)||0), 0);
      const off0 = sum(thisWeek, r=> +r.office_minutes||0);
      const off1 = sum(lastWeek, r=> +r.office_minutes||0);
      const rte0 = sum(thisWeek, r=> routeAdjustedHours(r));
      const rte1 = sum(lastWeek, r=> routeAdjustedHours(r));
      const tot0 = sum(thisWeek, r=> +r.hours||0);
      const tot1 = sum(lastWeek, r=> +r.hours||0);

      const dOff = off0 - off1;
      const dRte = rte0 - rte1;
      const dTot = tot0 - tot1;
      const baseTot = tot1 > 0 ? tot1 : null;
      const pct = (delta)=> (baseTot && delta!=null) ? Math.round((delta/baseTot)*100) : null;
      const pill = (label, delta)=>{
        const p = pct(delta);
        const txt = delta==null ? '—' : `${delta>=0?'+':''}${(Math.round(delta*10)/10).toFixed(1)}h`;
        const pTxt = (p==null)? '' : ` (${p>=0?'+':''}${p}%)`;
        const col = colorForDelta(p || 0).fg;
        return `<span class="pill"><small>${label}</small> <b style="color:${col}">${txt}${pTxt}</b></span>`;
      };
      el.style.display='block';
      const pills = [pill('Office', dOff), pill('Route', dRte), pill('Total', dTot)].join(' ');
      el.innerHTML = `<small>Heaviness (week)</small><div class="pill-row">${pills}</div>`;
    }catch(_){ /* no-op */ }
  }

  // Office Time Compare overlay (this week vs last)
  function buildOfficeCompare(rows){
    rows = filterRowsForView(rows||[]);
    try{
      const card = document.getElementById('officeCompareCard'); if (!card) return;
      const overlay = document.getElementById('officeOverlay');
      const summary = document.getElementById('officeSummary');
      const now = DateTime.now().setZone(ZONE);
      const startThis = startOfWeekMonday(now);
      const endThis   = now.endOf('day');
      const inRange=(r,from,to)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=from && d<=to; };
      const worked = (rows||[]).filter(r=> r.status!=='off');
      const baseWeek = getLastNonEmptyWeek(worked, now, { excludeVacation: true });
      const startLast = baseWeek.start;
      const endLast   = baseWeek.end;
      const lastEndSame = luxon.DateTime.min(
        endLast,
        baseWeek.start.plus({ days: Math.max(0, now.weekday - 1) }).endOf('day')
      );
      const W0 = worked.filter(r=> inRange(r,startThis,endThis));
      const W1 = baseWeek.rows;
      const sum = (arr,fn)=> arr.reduce((t,x)=> t + (fn(x)||0), 0);
      const offByDow = (arr)=>{ const a=Array.from({length:7},()=>0); arr.forEach(r=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); const idx=(d.weekday+6)%7; a[idx]+= (+r.office_minutes||0); }); return a.map(n=> +(Math.round(n*100)/100).toFixed(2)); };
      const thisBy = offByDow(W0);
      const lastBy = offByDow(W1);
      const dayIdxToday = (now.weekday + 6) % 7;
      const thisMasked = thisBy.map((v,i)=> i<=dayIdxToday? v : null);
      const days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
      // Summary (Mon..today vs last Mon..today)
      const off0 = sum(W0.filter(r=> inRange(r,startThis, endThis && DateTime.fromJSDate(new Date()).setZone(ZONE))), r=> +r.office_minutes||0); // already filtered
      const off1same = sum(baseWeek.rows.filter(r=> inRange(r,startLast,lastEndSame)), r=> +r.office_minutes||0);
      const dPct = (off1same>0)? Math.round(((off0 - off1same)/off1same)*100) : null;
      if (summary) summary.textContent = `Office (so far): ${off0.toFixed(2)}h vs ${off1same.toFixed(2)}h (${dPct==null?'—':(dPct>=0?('↑ '+dPct+'%'):('↓ '+Math.abs(dPct)+'%'))})`;
      card.style.display='block';
      if (overlay && window.Chart && overlay.getContext){
        const ctx = overlay.getContext('2d');
        if (overlay._chart) { try{ overlay._chart.destroy(); }catch(_){ } }
        const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim()||'#2b7fff';
        const warn  = getComputedStyle(document.documentElement).getPropertyValue('--warn').trim() || '#FFD27A';
        const isoForPoint = (datasetIndex, idx) => {
          try{
            if (datasetIndex === 0) return startLast.plus({ days: idx }).toISODate();
            if (datasetIndex === 1) return startThis.plus({ days: idx }).toISODate();
          }catch(_){ }
          return null;
        };
        overlay._chart = new Chart(ctx, {
          type:'line',
          data:{ labels:days, datasets:[
            { label:'Last week', data:lastBy, borderColor:brand, backgroundColor:'transparent', tension:0.25, pointRadius:3, pointHoverRadius:6, pointHitRadius:14, borderWidth:2, spanGaps:true },
            { label:'This week', data:thisMasked, borderColor:warn,  backgroundColor:'transparent', tension:0.25, pointRadius:3, pointHoverRadius:6, pointHitRadius:14, borderWidth:2, spanGaps:true }
          ]},
          options:{ responsive:true, maintainAspectRatio:false,
            layout:{ padding:{ top:12, right:16, bottom:10, left:16 } },
            interaction:{ mode:'nearest', intersect:false },
            plugins:{ legend:{ display:false }, tooltip:{
              callbacks:{
                title:(items)=>{
                  if (!items || !items.length) return '';
                  const item = items[0];
                  const iso = isoForPoint(item.datasetIndex, item.dataIndex);
                  if (iso){
                    const dt = DateTime.fromISO(iso, { zone: ZONE });
                    return dt.toFormat('ccc • MMM d, yyyy') + vacGlyph(iso);
                  }
                  const lbl = item.label || '';
                  return lbl + vacGlyph(lbl);
                },
                label:(item)=>{
                  const i=item.dataIndex; const lw=lastBy[i]; const tw=thisBy[i];
                  const hasTw = i<=dayIdxToday && tw!=null;
                  return hasTw? `This: ${tw}h (Last: ${lw}h)` : `Last: ${lw}h`;
                }
              }
            }},
            scales:{ x:{ display:true, grid:{ display:false } }, y:{ display:false } }
          }
        });
      }
    }catch(_){ /* no-op */ }
  }

  // USPS tiles: Route Eff. vs eval, and Weekly $/h
  function buildUspsTiles(rows){
    try{
      rows = filterRowsForView(rows||[]);
      const routeTile = document.getElementById('tileUspsRouteEff');
      const hourlyTile= document.getElementById('tileUspsHourly');
      if (!routeTile || !hourlyTile) return;
      const show = !!(FLAGS && FLAGS.uspsEval);
      routeTile.style.display = show ? '' : 'none';
      hourlyTile.style.display= show ? '' : 'none';
      if (!show) return;
      const cfg = USPS_EVAL || loadEval();
      // Hours vs eval (this week, running total Mon..today) — includes office time
      try{
        const now = DateTime.now().setZone(ZONE);
        const start = startOfWeekMonday(now);
        const end   = now.endOf('day');
        const inRange=(r)=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=start && d<=end; };
        const worked = (rows||[]).filter(r=> r.status!=='off' && inRange(r));
        const days = Array.from(new Set(worked.map(r=> r.work_date))).length;
        const valEl = document.getElementById('uspsRouteEffVal');
        if (!days || cfg.hoursPerDay==null){ valEl.textContent='—'; valEl.style.color=''; }
        else {
          const expHoursTotal = Math.max(0, cfg.hoursPerDay) * days;
          const hoursTotal = worked.reduce((t,r)=> t + (+r.hours||0), 0);
          const progress = (expHoursTotal>0) ? (hoursTotal / expHoursTotal) * 100 : null;
          if (progress==null || !isFinite(progress)) { valEl.textContent='—'; valEl.style.color=''; }
          else {
            const s = Math.round(progress);
            valEl.textContent = `${s}%`;
            valEl.style.color = '';
            valEl.title = `${(Math.round(hoursTotal*100)/100).toFixed(2)}h of ${(Math.round(expHoursTotal*100)/100).toFixed(2)}h eval over ${days} day(s)`;
          }
        }
      }catch(_){ /* ignore */ }
      // Weekly hourly rate — 4-week rolling average of $/h
      try{
        const now = DateTime.now().setZone(ZONE);
        const weeksBack = 4;
        const ranges = [];
        for (let w=1; w<=weeksBack; w++){
          ranges.push({ s: startOfWeekMonday(now.minus({weeks:w})), e: endOfWeekSunday(now.minus({weeks:w})) });
        }
        const val = document.getElementById('uspsHourlyRateVal');
        if (!cfg || cfg.annualSalary==null){ val.textContent='—'; val.style.color=''; }
        else {
          const weeklyPay = cfg.annualSalary / 52;
          let totalHours = 0, usedWeeks = 0;
          for (const rg of ranges){
            const wk = (rows||[]).filter(r=> r.status!=='off' && (()=>{ const d=DateTime.fromISO(r.work_date,{zone:ZONE}); return d>=rg.s && d<=rg.e; })());
            const h = wk.reduce((t,r)=> t + (+r.hours||0), 0);
            if (h > 0){ totalHours += h; usedWeeks++; }
          }
          if (!usedWeeks || totalHours<=0){
            val.textContent='—'; val.style.color='';
          } else {
            // Weighted average across weeks: (usedWeeks * weeklyPay) / totalHours
            const rate = (usedWeeks * weeklyPay) / totalHours;
            val.textContent = `$${(Math.round(rate*100)/100).toFixed(2)}`;
            val.title = `${usedWeeks}wk avg: ${totalHours.toFixed(2)}h total`;
            val.style.color='';
          }
        }
      }catch(_){ /* ignore */ }
    }catch(_){ /* ignore */ }
  }

  // Quick Filter (Phase 3): weekday selector with stats + optional sparkline
  function buildQuickFilter(rows){
    rows = filterRowsForView(rows||[]);
    const card = document.getElementById('quickFilterCard');
    if (!card) return;
    card.style.display = FLAGS.quickFilter ? 'block' : 'none';
    if (!FLAGS.quickFilter) return;
    const sel = document.getElementById('qfSelect');
    const stats = document.getElementById('qfStats');
    const spark = document.getElementById('qfSpark');
    const text = document.getElementById('qfText');
    const cbAll = document.getElementById('qfAllMetrics');
    const cbP = document.getElementById('qfShowParcels');
    const cbL = document.getElementById('qfShowLetters');
    const cbH = document.getElementById('qfShowHours');
    const selN = document.getElementById('qfLastN');
    const cbRuler = document.getElementById('qfShowRuler');
    const normBadge = document.getElementById('qfNormBadge');
    if (!stats || !spark || !text) return;

    const dayVal = (sel && sel.value) || 'all';
    const worked = (rows||[]).filter(r=> r.status!=='off');
    const filtered = worked.filter(r=> dayVal==='all' ? true : (DateTime.fromISO(r.work_date,{zone:ZONE}).weekday%7) == +dayVal);

    const count = filtered.length;
    const sum = (arr,fn)=> arr.reduce((t,x)=> t + (fn(x)||0), 0);
    const avg = (arr,fn)=> arr.length? sum(arr,fn)/arr.length : null;
    const avgH = avg(filtered, r=> +r.hours||0);
    const avgP = avg(filtered, r=> +r.parcels||0);
    const avgL = avg(filtered, r=> +r.letters||0);
    const avgR = avg(filtered, r=> +r.route_minutes||0);

    // Pills
    const pill = (label,val,fmt)=> `<span class="pill"><small>${label}:</small> <b>${fmt(val)}</b></span>`;
    const nf = (v)=> v==null? '—' : (typeof v==='number'? (Math.round(v*100)/100).toString() : String(v));
    stats.innerHTML = [
      pill('Days', count, nf),
      pill('Avg hours', avgH, v=> v==null?'—':(Math.round(v*100)/100).toFixed(2)),
      pill('Avg parcels', avgP, v=> v==null?'—':Math.round(v)),
      pill('Avg letters', avgL, v=> v==null?'—':Math.round(v)),
      pill('Avg route min', avgR, v=> v==null?'—':Math.round(v))
    ].join('');

    // Viz: tiny line(s) over last up to 12 filtered entries
    const available = filtered.length;
    const lastCount = (selN && +selN.value) || +(localStorage.getItem('routeStats.qf.lastN')||12) || 12;
    if (selN) selN.value = String(lastCount);
    // Disable Last N options that exceed available points (per current filter)
    if (selN && selN.options) {
      try{
        Array.from(selN.options).forEach(o=>{ o.disabled = (+o.value) > available; });
      }catch(_){ /* no-op */ }
    }
    const lastN = filtered
      .slice()
      .sort((a,b)=> (a.work_date < b.work_date ? -1 : 1))
      .slice(-lastCount);
    const labels = lastN.map(r=> DateTime.fromISO(r.work_date,{zone:ZONE}).toFormat('LLL d'));
    // Restore persisted ruler preference once
    try{
      if (cbRuler && typeof buildQuickFilter._rulerInit === 'undefined'){
        const pref = localStorage.getItem('routeStats.qf.ruler');
        if (pref != null) cbRuler.checked = pref === '1';
        buildQuickFilter._rulerInit = true;
      }
    }catch(_){ /* ignore */ }

    const showP = cbP ? !!cbP.checked : true;
    const showL = cbL ? !!cbL.checked : true;
    const showH = cbH ? !!cbH.checked : true;
    if (cbAll) cbAll.checked = !!(showP && showL && showH);
    const serP = lastN.map(r=> +r.parcels||0);
    const serL = lastN.map(r=> +r.letters||0);
    const serH = lastN.map(r=> +r.hours||0);
    const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim()||'#2b7fff';
    const warn  = getComputedStyle(document.documentElement).getPropertyValue('--warn').trim() || '#FFD27A';
    const good  = getComputedStyle(document.documentElement).getPropertyValue('--good').trim() || '#2E7D32';
    const datasets = [];
    // Normalize if plotting multiple metrics to make lines comparable on the same sparkline
    const needNormalize = [showP, showL, showH].filter(Boolean).length > 1;
    const norm = (arr)=>{
      const vals = arr || [];
      let min = Infinity, max = -Infinity;
      for (const v of vals){ if (v==null) continue; if (v<min) min=v; if (v>max) max=v; }
      if (!isFinite(min) || !isFinite(max)) return vals.map(_=> null);
      if (max === min) return vals.map(_=> 50); // flat line mid if no variance
      return vals.map(v=> v==null? null : Math.round( ( (v - min) / (max - min) ) * 100 ));
    };
    const dataP = needNormalize ? norm(serP) : serP;
    const dataL = needNormalize ? norm(serL) : serL;
    const dataH = needNormalize ? norm(serH) : serH;
    if (showP) datasets.push({ label:'Parcels', data: dataP, borderColor:brand, backgroundColor:'transparent', tension:0.25, pointRadius:2, borderWidth:2, spanGaps:true });
    if (showL) datasets.push({ label:'Letters', data: dataL, borderColor:warn,  backgroundColor:'transparent', tension:0.25, pointRadius:2, borderWidth:2, spanGaps:true });
    if (showH) datasets.push({ label:'Hours',   data: dataH, borderColor:good,  backgroundColor:'transparent', tension:0.25, pointRadius:2, borderWidth:2, spanGaps:true });
    const summary = [];
    const fmtNum = (n)=> (Math.round(n*10)/10).toFixed(1);
    if (showP) summary.push(`P: ${serP.slice(-labels.length).map(fmtNum).join(', ')}`);
    if (showL) summary.push(`L: ${serL.slice(-labels.length).map(fmtNum).join(', ')}`);
    if (showH) summary.push(`H: ${serH.slice(-labels.length).map(fmtNum).join(', ')}`);
    const showing = labels.length;
    const requested = lastCount;
    const note = needNormalize ? ' (normalized)' : '';
    if (normBadge) normBadge.style.display = needNormalize ? 'inline-flex' : 'none';
    const coverage = `Showing ${showing} of ${requested} requested${available?`, available ${available}`:''}`;
    text.textContent = datasets.length ? `${summary.join(' • ')} — ${coverage}${note}` : '—';
    // Days badge near legend
    const daysBadge = document.getElementById('qfDaysBadge');
    if (daysBadge){ daysBadge.style.display='inline-flex'; daysBadge.innerHTML = `<small>Days</small> <b>${count}</b>`; }

    if (window.Chart && spark.getContext){
      try{
        const ctx = spark.getContext('2d');
        if (spark._chart) { try{ spark._chart.destroy(); }catch(_){} }
        try{ spark.height = 64; }catch(_){ }
        const wantRuler = (cbRuler ? !!cbRuler.checked : false) && needNormalize;
        spark._chart = new Chart(ctx, {
          type:'line',
          data:{ labels, datasets: datasets.map(d => Object.assign({ tension:0.25, pointRadius:2, borderWidth:2, spanGaps:true, fill:false }, d)) },
          options:{
            responsive:true,
            maintainAspectRatio:false,
            layout:{ padding:{ top:8, right:6, bottom:6, left:6 } },
            interaction:{ mode:'nearest', intersect:false },
            plugins:{ legend:{ display:false }, tooltip:{ enabled:true } },
            scales:{
              x:{ display:false, grid:{ display:false } },
              y:{
                display: wantRuler,
                min: needNormalize ? 0 : undefined,
                max: needNormalize ? 100 : undefined,
                ticks:{ display:false, stepSize:50 },
                grid:{ display: wantRuler, color:'rgba(255,255,255,0.08)' }
              }
            }
          }
        });
      }catch(_){ /* fallback already set in text */ }
    }

    // Hook change
    const handler = ()=> buildQuickFilter(rows);
    // Rebind events
    sel?.removeEventListener('change', buildQuickFilter._handlerSel || (()=>{}));
    cbP?.removeEventListener('change', buildQuickFilter._handlerP || (()=>{}));
    cbL?.removeEventListener('change', buildQuickFilter._handlerL || (()=>{}));
    cbH?.removeEventListener('change', buildQuickFilter._handlerH || (()=>{}));
    selN?.removeEventListener('change', buildQuickFilter._handlerN || (()=>{}));
    cbAll?.removeEventListener('change', buildQuickFilter._handlerAll || (()=>{}));
    cbRuler?.removeEventListener('change', buildQuickFilter._handlerRuler || (()=>{}));
    buildQuickFilter._handlerSel = (e)=>{
      // Auto-expand Quick Filter when a day is selected and the section is collapsed
      try{
        if (FLAGS && FLAGS.collapsedUi){
          const body = document.querySelector('#quickFilterCard > .__collapseBody');
          if (body && body.style.display === 'none'){
            try{ (window.__collapse_set||(()=>{}))('quickFilterCard', false); }catch(_){ }
          }
        }
      }catch(_){ }
      handler();
    };
    buildQuickFilter._handlerP = handler;
    buildQuickFilter._handlerL = handler;
    buildQuickFilter._handlerH = handler;
    buildQuickFilter._handlerN = (e)=>{ try{ localStorage.setItem('routeStats.qf.lastN', String(e.target.value)); }catch(_){} handler(); };
    buildQuickFilter._handlerAll = ()=>{
      const on = !!cbAll.checked;
      if (cbP) cbP.checked = on;
      if (cbL) cbL.checked = on;
      if (cbH) cbH.checked = on;
      handler();
    };
    buildQuickFilter._handlerRuler = (e)=>{ try{ localStorage.setItem('routeStats.qf.ruler', e.target.checked ? '1' : '0'); }catch(_){} handler(); };
    sel?.addEventListener('change', buildQuickFilter._handlerSel);
    cbP?.addEventListener('change', handler);
    cbL?.addEventListener('change', handler);
    cbH?.addEventListener('change', handler);
    selN?.addEventListener('change', buildQuickFilter._handlerN);
    cbAll?.addEventListener('change', buildQuickFilter._handlerAll);
    cbRuler?.addEventListener('change', buildQuickFilter._handlerRuler);
  }
</script>
</body>
</html>
